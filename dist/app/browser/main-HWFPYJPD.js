import { a as lt, b as ct, c as pt, d as gt } from "./chunk-3DNVKCOB.js";
import {
  b as vn,
  d as bn,
  e as En,
  f as Sn,
  g as zn,
} from "./chunk-WOO2F2QC.js";
import {
  $ as Ce,
  $c as dt,
  A as it,
  Ab as sn,
  Ac as An,
  B as Oe,
  Ba as j,
  Bc as Pn,
  Ca as S,
  Cc as In,
  Da as $t,
  Dc as Dn,
  Ea as qi,
  F as nt,
  Fa as Qi,
  Fc as Yt,
  Ga as $i,
  Gb as rn,
  Gc as kn,
  H as Kt,
  Ha as Ui,
  Hb as z,
  Ia as he,
  Ja as Hi,
  Jc as Nn,
  Kb as Wt,
  La as Ut,
  Lb as on,
  Lc as Rn,
  Mb as an,
  Oa as xe,
  Oc as v,
  Pc as J,
  Q as st,
  Qc as Xt,
  R as Vt,
  Rb as Gt,
  Rc as mt,
  S as rt,
  Sa as Be,
  T as xi,
  Ta as je,
  Tb as qe,
  Tc as Fn,
  U as E,
  Ua as W,
  Uc as se,
  Vb as ne,
  Vc as Zt,
  W as Me,
  Wa as Pe,
  Wc as ut,
  Xa as Wi,
  Xb as ln,
  Yb as cn,
  Z as Le,
  Za as at,
  Zb as mn,
  Zc as De,
  _a as Gi,
  _c as Jt,
  a as Ze,
  aa as N,
  ab as Yi,
  ac as le,
  ba as w,
  bb as Xi,
  c as zi,
  ca as L,
  cb as C,
  d as Je,
  db as A,
  dc as un,
  e as zt,
  ea as Ae,
  eb as Q,
  f as xt,
  fc as dn,
  g as et,
  ga as Bi,
  gc as hn,
  gd as On,
  hd as ht,
  ib as Ke,
  ic as fn,
  ja as te,
  jc as pn,
  jd as ft,
  ka as ie,
  kc as gn,
  kd as Ln,
  l as tt,
  la as ji,
  lb as fe,
  lc as yn,
  mc as _n,
  md as xn,
  n as Bt,
  nb as $,
  nd as Bn,
  ob as Ve,
  od as jn,
  pa as qt,
  pb as pe,
  pc as wn,
  pd as Kn,
  q as jt,
  qb as Zi,
  qd as Vn,
  rb as Ie,
  rc as Tn,
  rd as qn,
  sb as Ji,
  sd as Qn,
  ta as Qt,
  tb as ge,
  tc as Mn,
  ua as H,
  ub as ye,
  ud as $n,
  va as ot,
  vb as Ht,
  wa as Ki,
  wb as en,
  xa as ze,
  xb as tn,
  yb as Z,
  za as Vi,
  zb as nn,
  zc as Cn,
} from "./chunk-ILZMJO4D.js";
var Un = {
  production: !0,
  apiEndpoints: {
    product: "https://.execute-api.eu-west-1.amazonaws.com/dev",
    order: "https://.execute-api.eu-west-1.amazonaws.com/dev",
    import: "https://.execute-api.eu-west-1.amazonaws.com/dev",
    bff: "https://.execute-api.eu-west-1.amazonaws.com/dev",
    cart: "https://.execute-api.eu-west-1.amazonaws.com/dev",
  },
  apiEndpointsEnabled: {
    product: !1,
    order: !1,
    import: !1,
    bff: !1,
    cart: !1,
  },
};
var zs = 0,
  Hn = "mat-badge-content",
  yt = new Set(),
  xs = (() => {
    let e = class e {};
    (e.ɵfac = function (n) {
      return new (n || e)();
    }),
      (e.ɵcmp = L({
        type: e,
        selectors: [["ng-component"]],
        standalone: !0,
        features: [z],
        decls: 0,
        vars: 0,
        template: function (n, s) {},
        styles: [
          ".mat-badge{position:relative}.mat-badge.mat-badge{overflow:visible}.mat-badge-content{position:absolute;text-align:center;display:inline-block;transition:transform 200ms ease-in-out;transform:scale(0.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;box-sizing:border-box;pointer-events:none;background-color:var(--mat-badge-background-color);color:var(--mat-badge-text-color);font-family:var(--mat-badge-text-font);font-weight:var(--mat-badge-text-weight);border-radius:var(--mat-badge-container-shape)}.cdk-high-contrast-active .mat-badge-content{outline:solid 1px;border-radius:0}.mat-badge-above .mat-badge-content{bottom:100%}.mat-badge-below .mat-badge-content{top:100%}.mat-badge-before .mat-badge-content{right:100%}[dir=rtl] .mat-badge-before .mat-badge-content{right:auto;left:100%}.mat-badge-after .mat-badge-content{left:100%}[dir=rtl] .mat-badge-after .mat-badge-content{left:auto;right:100%}.mat-badge-disabled .mat-badge-content{background-color:var(--mat-badge-disabled-state-background-color);color:var(--mat-badge-disabled-state-text-color)}.mat-badge-hidden .mat-badge-content{display:none}.ng-animate-disabled .mat-badge-content,.mat-badge-content._mat-animation-noopable{transition:none}.mat-badge-content.mat-badge-active{transform:none}.mat-badge-small .mat-badge-content{width:var(--mat-badge-legacy-small-size-container-size, unset);height:var(--mat-badge-legacy-small-size-container-size, unset);min-width:var(--mat-badge-small-size-container-size, unset);min-height:var(--mat-badge-small-size-container-size, unset);line-height:var(--mat-badge-legacy-small-size-container-size, var(--mat-badge-small-size-container-size));padding:var(--mat-badge-small-size-container-padding);font-size:var(--mat-badge-small-size-text-size);margin:var(--mat-badge-small-size-container-offset)}.mat-badge-small.mat-badge-overlap .mat-badge-content{margin:var(--mat-badge-small-size-container-overlap-offset)}.mat-badge-medium .mat-badge-content{width:var(--mat-badge-legacy-container-size, unset);height:var(--mat-badge-legacy-container-size, unset);min-width:var(--mat-badge-container-size, unset);min-height:var(--mat-badge-container-size, unset);line-height:var(--mat-badge-legacy-container-size, var(--mat-badge-container-size));padding:var(--mat-badge-container-padding);font-size:var(--mat-badge-text-size);margin:var(--mat-badge-container-offset)}.mat-badge-medium.mat-badge-overlap .mat-badge-content{margin:var(--mat-badge-container-overlap-offset)}.mat-badge-large .mat-badge-content{width:var(--mat-badge-legacy-large-size-container-size, unset);height:var(--mat-badge-legacy-large-size-container-size, unset);min-width:var(--mat-badge-large-size-container-size, unset);min-height:var(--mat-badge-large-size-container-size, unset);line-height:var(--mat-badge-legacy-large-size-container-size, var(--mat-badge-large-size-container-size));padding:var(--mat-badge-large-size-container-padding);font-size:var(--mat-badge-large-size-text-size);margin:var(--mat-badge-large-size-container-offset)}.mat-badge-large.mat-badge-overlap .mat-badge-content{margin:var(--mat-badge-large-size-container-overlap-offset)}",
        ],
        encapsulation: 2,
        changeDetection: 0,
      }));
    let r = e;
    return r;
  })(),
  Wn = (() => {
    let e = class e {
      get color() {
        return this._color;
      }
      set color(i) {
        this._setColor(i), (this._color = i);
      }
      get content() {
        return this._content;
      }
      set content(i) {
        this._updateRenderedContent(i);
      }
      get description() {
        return this._description;
      }
      set description(i) {
        this._updateDescription(i);
      }
      constructor(i, n, s, o, a) {
        (this._ngZone = i),
          (this._elementRef = n),
          (this._ariaDescriber = s),
          (this._renderer = o),
          (this._animationMode = a),
          (this._color = "primary"),
          (this.overlap = !0),
          (this.position = "above after"),
          (this.size = "medium"),
          (this._id = zs++),
          (this._isInitialized = !1),
          (this._interactivityChecker = N(Pn)),
          (this._document = N(le));
        let l = N(Gt);
        if (!yt.has(l)) {
          yt.add(l);
          let c = mn(xs, { environmentInjector: N(Bi) });
          l.onDestroy(() => {
            yt.delete(l), yt.size === 0 && c.destroy();
          });
        }
      }
      isAbove() {
        return this.position.indexOf("below") === -1;
      }
      isAfter() {
        return this.position.indexOf("before") === -1;
      }
      getBadgeElement() {
        return this._badgeElement;
      }
      ngOnInit() {
        this._clearExistingBadges(),
          this.content &&
            !this._badgeElement &&
            ((this._badgeElement = this._createBadgeElement()),
            this._updateRenderedContent(this.content)),
          (this._isInitialized = !0);
      }
      ngOnDestroy() {
        this._renderer.destroyNode &&
          (this._renderer.destroyNode(this._badgeElement),
          this._inlineBadgeDescription?.remove()),
          this._ariaDescriber.removeDescription(
            this._elementRef.nativeElement,
            this.description,
          );
      }
      _isHostInteractive() {
        return this._interactivityChecker.isFocusable(
          this._elementRef.nativeElement,
          { ignoreVisibility: !0 },
        );
      }
      _createBadgeElement() {
        let i = this._renderer.createElement("span"),
          n = "mat-badge-active";
        return (
          i.setAttribute("id", `mat-badge-content-${this._id}`),
          i.setAttribute("aria-hidden", "true"),
          i.classList.add(Hn),
          this._animationMode === "NoopAnimations" &&
            i.classList.add("_mat-animation-noopable"),
          this._elementRef.nativeElement.appendChild(i),
          typeof requestAnimationFrame == "function" &&
          this._animationMode !== "NoopAnimations"
            ? this._ngZone.runOutsideAngular(() => {
                requestAnimationFrame(() => {
                  i.classList.add(n);
                });
              })
            : i.classList.add(n),
          i
        );
      }
      _updateRenderedContent(i) {
        let n = `${i ?? ""}`.trim();
        this._isInitialized &&
          n &&
          !this._badgeElement &&
          (this._badgeElement = this._createBadgeElement()),
          this._badgeElement && (this._badgeElement.textContent = n),
          (this._content = n);
      }
      _updateDescription(i) {
        this._ariaDescriber.removeDescription(
          this._elementRef.nativeElement,
          this.description,
        ),
          (!i || this._isHostInteractive()) && this._removeInlineDescription(),
          (this._description = i),
          this._isHostInteractive()
            ? this._ariaDescriber.describe(this._elementRef.nativeElement, i)
            : this._updateInlineDescription();
      }
      _updateInlineDescription() {
        this._inlineBadgeDescription ||
          ((this._inlineBadgeDescription =
            this._document.createElement("span")),
          this._inlineBadgeDescription.classList.add("cdk-visually-hidden")),
          (this._inlineBadgeDescription.textContent = this.description),
          this._badgeElement?.appendChild(this._inlineBadgeDescription);
      }
      _removeInlineDescription() {
        this._inlineBadgeDescription?.remove(),
          (this._inlineBadgeDescription = void 0);
      }
      _setColor(i) {
        let n = this._elementRef.nativeElement.classList;
        n.remove(`mat-badge-${this._color}`), i && n.add(`mat-badge-${i}`);
      }
      _clearExistingBadges() {
        let i = this._elementRef.nativeElement.querySelectorAll(
          `:scope > .${Hn}`,
        );
        for (let n of Array.from(i)) n !== this._badgeElement && n.remove();
      }
    };
    (e.ɵfac = function (n) {
      return new (n || e)(S(he), S(H), S(Cn), S($i), S(ze, 8));
    }),
      (e.ɵdir = Ae({
        type: e,
        selectors: [["", "matBadge", ""]],
        hostAttrs: [1, "mat-badge"],
        hostVars: 20,
        hostBindings: function (n, s) {
          n & 2 &&
            Pe("mat-badge-overlap", s.overlap)("mat-badge-above", s.isAbove())(
              "mat-badge-below",
              !s.isAbove(),
            )("mat-badge-before", !s.isAfter())("mat-badge-after", s.isAfter())(
              "mat-badge-small",
              s.size === "small",
            )("mat-badge-medium", s.size === "medium")(
              "mat-badge-large",
              s.size === "large",
            )("mat-badge-hidden", s.hidden || !s.content)(
              "mat-badge-disabled",
              s.disabled,
            );
        },
        inputs: {
          color: [w.None, "matBadgeColor", "color"],
          overlap: [
            w.HasDecoratorInputTransform,
            "matBadgeOverlap",
            "overlap",
            ne,
          ],
          disabled: [
            w.HasDecoratorInputTransform,
            "matBadgeDisabled",
            "disabled",
            ne,
          ],
          position: [w.None, "matBadgePosition", "position"],
          content: [w.None, "matBadge", "content"],
          description: [w.None, "matBadgeDescription", "description"],
          size: [w.None, "matBadgeSize", "size"],
          hidden: [
            w.HasDecoratorInputTransform,
            "matBadgeHidden",
            "hidden",
            ne,
          ],
        },
        standalone: !0,
        features: [xe],
      }));
    let r = e;
    return r;
  })();
var Qs = ["mat-menu-item", ""],
  $s = [[["mat-icon"], ["", "matMenuItemIcon", ""]], "*"],
  Us = ["mat-icon, [matMenuItemIcon]", "*"];
function Hs(r, e) {
  r & 1 && (ji(), C(0, "svg", 2), Q(1, "polygon", 3), A());
}
var Ws = ["*"];
function Gs(r, e) {
  if (r & 1) {
    let t = Ke();
    C(0, "div", 0),
      fe("keydown", function (n) {
        te(t);
        let s = $();
        return ie(s._handleKeydown(n));
      })("click", function () {
        te(t);
        let n = $();
        return ie(n.closed.emit("click"));
      })("@transformMenu.start", function (n) {
        te(t);
        let s = $();
        return ie(s._onAnimationStart(n));
      })("@transformMenu.done", function (n) {
        te(t);
        let s = $();
        return ie(s._onAnimationDone(n));
      }),
      C(1, "div", 1),
      pe(2),
      A()();
  }
  if (r & 2) {
    let t = $();
    W("id", t.panelId)("ngClass", t._classList)(
      "@transformMenu",
      t._panelAnimationState,
    ),
      je("aria-label", t.ariaLabel || null)(
        "aria-labelledby",
        t.ariaLabelledby || null,
      )("aria-describedby", t.ariaDescribedby || null);
  }
}
var ii = new Le("MAT_MENU_PANEL"),
  Qe = (() => {
    let e = class e {
      constructor(i, n, s, o, a) {
        (this._elementRef = i),
          (this._document = n),
          (this._focusMonitor = s),
          (this._parentMenu = o),
          (this._changeDetectorRef = a),
          (this.role = "menuitem"),
          (this.disabled = !1),
          (this.disableRipple = !1),
          (this._hovered = new tt()),
          (this._focused = new tt()),
          (this._highlighted = !1),
          (this._triggersSubmenu = !1),
          o?.addItem?.(this);
      }
      focus(i, n) {
        this._focusMonitor && i
          ? this._focusMonitor.focusVia(this._getHostElement(), i, n)
          : this._getHostElement().focus(n),
          this._focused.next(this);
      }
      ngAfterViewInit() {
        this._focusMonitor && this._focusMonitor.monitor(this._elementRef, !1);
      }
      ngOnDestroy() {
        this._focusMonitor &&
          this._focusMonitor.stopMonitoring(this._elementRef),
          this._parentMenu &&
            this._parentMenu.removeItem &&
            this._parentMenu.removeItem(this),
          this._hovered.complete(),
          this._focused.complete();
      }
      _getTabIndex() {
        return this.disabled ? "-1" : "0";
      }
      _getHostElement() {
        return this._elementRef.nativeElement;
      }
      _checkDisabled(i) {
        this.disabled && (i.preventDefault(), i.stopPropagation());
      }
      _handleMouseEnter() {
        this._hovered.next(this);
      }
      getLabel() {
        let i = this._elementRef.nativeElement.cloneNode(!0),
          n = i.querySelectorAll("mat-icon, .material-icons");
        for (let s = 0; s < n.length; s++) n[s].remove();
        return i.textContent?.trim() || "";
      }
      _setHighlighted(i) {
        (this._highlighted = i), this._changeDetectorRef?.markForCheck();
      }
      _setTriggersSubmenu(i) {
        (this._triggersSubmenu = i), this._changeDetectorRef?.markForCheck();
      }
      _hasFocus() {
        return (
          this._document &&
          this._document.activeElement === this._getHostElement()
        );
      }
    };
    (e.ɵfac = function (n) {
      return new (n || e)(S(H), S(le), S(Yt), S(ii, 8), S(qe));
    }),
      (e.ɵcmp = L({
        type: e,
        selectors: [["", "mat-menu-item", ""]],
        hostAttrs: [1, "mat-mdc-menu-item", "mat-mdc-focus-indicator"],
        hostVars: 8,
        hostBindings: function (n, s) {
          n & 1 &&
            fe("click", function (a) {
              return s._checkDisabled(a);
            })("mouseenter", function () {
              return s._handleMouseEnter();
            }),
            n & 2 &&
              (je("role", s.role)("tabindex", s._getTabIndex())(
                "aria-disabled",
                s.disabled,
              )("disabled", s.disabled || null),
              Pe("mat-mdc-menu-item-highlighted", s._highlighted)(
                "mat-mdc-menu-item-submenu-trigger",
                s._triggersSubmenu,
              ));
        },
        inputs: {
          role: "role",
          disabled: [w.HasDecoratorInputTransform, "disabled", "disabled", ne],
          disableRipple: [
            w.HasDecoratorInputTransform,
            "disableRipple",
            "disableRipple",
            ne,
          ],
        },
        exportAs: ["matMenuItem"],
        standalone: !0,
        features: [xe, z],
        attrs: Qs,
        ngContentSelectors: Us,
        decls: 5,
        vars: 3,
        consts: [
          [1, "mat-mdc-menu-item-text"],
          [
            "matRipple",
            "",
            1,
            "mat-mdc-menu-ripple",
            3,
            "matRippleDisabled",
            "matRippleTrigger",
          ],
          [
            "viewBox",
            "0 0 5 10",
            "focusable",
            "false",
            "aria-hidden",
            "true",
            1,
            "mat-mdc-menu-submenu-icon",
          ],
          ["points", "0,0 5,5 0,10"],
        ],
        template: function (n, s) {
          n & 1 &&
            (Ve($s),
            pe(0),
            C(1, "span", 0),
            pe(2, 1),
            A(),
            Q(3, "div", 1),
            Be(4, Hs, 2, 0, ":svg:svg", 2)),
            n & 2 &&
              (j(3),
              W("matRippleDisabled", s.disableRipple || s.disabled)(
                "matRippleTrigger",
                s._getHostElement(),
              ),
              j(),
              at(4, s._triggersSubmenu ? 4 : -1));
        },
        dependencies: [Nn],
        encapsulation: 2,
        changeDetection: 0,
      }));
    let r = e;
    return r;
  })();
var Ys = new Le("MatMenuContent");
var _t = {
    transformMenu: Xt("transformMenu", [
      Zt("void", se({ opacity: 0, transform: "scale(0.8)" })),
      ut(
        "void => enter",
        mt(
          "120ms cubic-bezier(0, 0, 0.2, 1)",
          se({ opacity: 1, transform: "scale(1)" }),
        ),
      ),
      ut("* => void", mt("100ms 25ms linear", se({ opacity: 0 }))),
    ]),
    fadeInItems: Xt("fadeInItems", [
      Zt("showing", se({ opacity: 1 })),
      ut("void => *", [
        se({ opacity: 0 }),
        mt("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)"),
      ]),
    ]),
  },
  Na = _t.fadeInItems,
  Ra = _t.transformMenu,
  Xs = 0,
  Zs = new Le("mat-menu-default-options", { providedIn: "root", factory: Js });
function Js() {
  return {
    overlapTrigger: !1,
    xPosition: "after",
    yPosition: "below",
    backdropClass: "cdk-overlay-transparent-backdrop",
  };
}
var ke = (() => {
    let e = class e {
      get xPosition() {
        return this._xPosition;
      }
      set xPosition(i) {
        (this._xPosition = i), this.setPositionClasses();
      }
      get yPosition() {
        return this._yPosition;
      }
      set yPosition(i) {
        (this._yPosition = i), this.setPositionClasses();
      }
      set panelClass(i) {
        let n = this._previousPanelClass;
        n &&
          n.length &&
          n.split(" ").forEach((s) => {
            this._classList[s] = !1;
          }),
          (this._previousPanelClass = i),
          i &&
            i.length &&
            (i.split(" ").forEach((s) => {
              this._classList[s] = !0;
            }),
            (this._elementRef.nativeElement.className = ""));
      }
      get classList() {
        return this.panelClass;
      }
      set classList(i) {
        this.panelClass = i;
      }
      constructor(i, n, s, o) {
        (this._elementRef = i),
          (this._ngZone = n),
          (this._changeDetectorRef = o),
          (this._elevationPrefix = "mat-elevation-z"),
          (this._baseElevation = 8),
          (this._directDescendantItems = new Ki()),
          (this._classList = {}),
          (this._panelAnimationState = "void"),
          (this._animationDone = new tt()),
          (this.closed = new ot()),
          (this.close = this.closed),
          (this.panelId = `mat-menu-panel-${Xs++}`),
          (this.overlayPanelClass = s.overlayPanelClass || ""),
          (this._xPosition = s.xPosition),
          (this._yPosition = s.yPosition),
          (this.backdropClass = s.backdropClass),
          (this.overlapTrigger = s.overlapTrigger),
          (this.hasBackdrop = s.hasBackdrop);
      }
      ngOnInit() {
        this.setPositionClasses();
      }
      ngAfterContentInit() {
        this._updateDirectDescendants(),
          (this._keyManager = new An(this._directDescendantItems)
            .withWrap()
            .withTypeAhead()
            .withHomeAndEnd()),
          this._keyManager.tabOut.subscribe(() => this.closed.emit("tab")),
          this._directDescendantItems.changes
            .pipe(
              st(this._directDescendantItems),
              Vt((i) => it(...i.map((n) => n._focused))),
            )
            .subscribe((i) => this._keyManager.updateActiveItem(i)),
          this._directDescendantItems.changes.subscribe((i) => {
            let n = this._keyManager;
            if (
              this._panelAnimationState === "enter" &&
              n.activeItem?._hasFocus()
            ) {
              let s = i.toArray(),
                o = Math.max(0, Math.min(s.length - 1, n.activeItemIndex || 0));
              s[o] && !s[o].disabled
                ? n.setActiveItem(o)
                : n.setNextItemActive();
            }
          });
      }
      ngOnDestroy() {
        this._keyManager?.destroy(),
          this._directDescendantItems.destroy(),
          this.closed.complete(),
          this._firstItemFocusSubscription?.unsubscribe();
      }
      _hovered() {
        return this._directDescendantItems.changes.pipe(
          st(this._directDescendantItems),
          Vt((n) => it(...n.map((s) => s._hovered))),
        );
      }
      addItem(i) {}
      removeItem(i) {}
      _handleKeydown(i) {
        let n = i.keyCode,
          s = this._keyManager;
        switch (n) {
          case 27:
            Mn(i) || (i.preventDefault(), this.closed.emit("keydown"));
            break;
          case 37:
            this.parentMenu &&
              this.direction === "ltr" &&
              this.closed.emit("keydown");
            break;
          case 39:
            this.parentMenu &&
              this.direction === "rtl" &&
              this.closed.emit("keydown");
            break;
          default:
            (n === 38 || n === 40) && s.setFocusOrigin("keyboard"),
              s.onKeydown(i);
            return;
        }
        i.stopPropagation();
      }
      focusFirstItem(i = "program") {
        this._firstItemFocusSubscription?.unsubscribe(),
          (this._firstItemFocusSubscription = this._ngZone.onStable
            .pipe(nt(1))
            .subscribe(() => {
              let n = null;
              if (
                (this._directDescendantItems.length &&
                  (n = this._directDescendantItems.first
                    ._getHostElement()
                    .closest('[role="menu"]')),
                !n || !n.contains(document.activeElement))
              ) {
                let s = this._keyManager;
                s.setFocusOrigin(i).setFirstItemActive(),
                  !s.activeItem && n && n.focus();
              }
            }));
      }
      resetActiveItem() {
        this._keyManager.setActiveItem(-1);
      }
      setElevation(i) {
        let n = Math.min(this._baseElevation + i, 24),
          s = `${this._elevationPrefix}${n}`,
          o = Object.keys(this._classList).find((a) =>
            a.startsWith(this._elevationPrefix),
          );
        (!o || o === this._previousElevation) &&
          (this._previousElevation &&
            (this._classList[this._previousElevation] = !1),
          (this._classList[s] = !0),
          (this._previousElevation = s));
      }
      setPositionClasses(i = this.xPosition, n = this.yPosition) {
        let s = this._classList;
        (s["mat-menu-before"] = i === "before"),
          (s["mat-menu-after"] = i === "after"),
          (s["mat-menu-above"] = n === "above"),
          (s["mat-menu-below"] = n === "below"),
          this._changeDetectorRef?.markForCheck();
      }
      _startAnimation() {
        this._panelAnimationState = "enter";
      }
      _resetAnimation() {
        this._panelAnimationState = "void";
      }
      _onAnimationDone(i) {
        this._animationDone.next(i), (this._isAnimating = !1);
      }
      _onAnimationStart(i) {
        (this._isAnimating = !0),
          i.toState === "enter" &&
            this._keyManager.activeItemIndex === 0 &&
            (i.element.scrollTop = 0);
      }
      _updateDirectDescendants() {
        this._allItems.changes.pipe(st(this._allItems)).subscribe((i) => {
          this._directDescendantItems.reset(
            i.filter((n) => n._parentMenu === this),
          ),
            this._directDescendantItems.notifyOnChanges();
        });
      }
    };
    (e.ɵfac = function (n) {
      return new (n || e)(S(H), S(he), S(Zs), S(qe));
    }),
      (e.ɵcmp = L({
        type: e,
        selectors: [["mat-menu"]],
        contentQueries: function (n, s, o) {
          if ((n & 1 && (Ie(o, Ys, 5), Ie(o, Qe, 5), Ie(o, Qe, 4)), n & 2)) {
            let a;
            ge((a = ye())) && (s.lazyContent = a.first),
              ge((a = ye())) && (s._allItems = a),
              ge((a = ye())) && (s.items = a);
          }
        },
        viewQuery: function (n, s) {
          if ((n & 1 && Ji($t, 5), n & 2)) {
            let o;
            ge((o = ye())) && (s.templateRef = o.first);
          }
        },
        hostVars: 3,
        hostBindings: function (n, s) {
          n & 2 &&
            je("aria-label", null)("aria-labelledby", null)(
              "aria-describedby",
              null,
            );
        },
        inputs: {
          backdropClass: "backdropClass",
          ariaLabel: [w.None, "aria-label", "ariaLabel"],
          ariaLabelledby: [w.None, "aria-labelledby", "ariaLabelledby"],
          ariaDescribedby: [w.None, "aria-describedby", "ariaDescribedby"],
          xPosition: "xPosition",
          yPosition: "yPosition",
          overlapTrigger: [
            w.HasDecoratorInputTransform,
            "overlapTrigger",
            "overlapTrigger",
            ne,
          ],
          hasBackdrop: [
            w.HasDecoratorInputTransform,
            "hasBackdrop",
            "hasBackdrop",
            (i) => (i == null ? null : ne(i)),
          ],
          panelClass: [w.None, "class", "panelClass"],
          classList: "classList",
        },
        outputs: { closed: "closed", close: "close" },
        exportAs: ["matMenu"],
        standalone: !0,
        features: [rn([{ provide: ii, useExisting: e }]), xe, z],
        ngContentSelectors: Ws,
        decls: 1,
        vars: 0,
        consts: [
          [
            "tabindex",
            "-1",
            "role",
            "menu",
            1,
            "mat-mdc-menu-panel",
            "mat-mdc-elevation-specific",
            3,
            "keydown",
            "click",
            "id",
            "ngClass",
          ],
          [1, "mat-mdc-menu-content"],
        ],
        template: function (n, s) {
          n & 1 && (Ve(), Be(0, Gs, 3, 6, "ng-template"));
        },
        dependencies: [un],
        styles: [
          'mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;list-style-type:none}.mat-mdc-menu-content:focus{outline:none}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font);line-height:var(--mat-menu-item-label-text-line-height);font-size:var(--mat-menu-item-label-text-size);letter-spacing:var(--mat-menu-item-label-text-tracking);font-weight:var(--mat-menu-item-label-text-weight)}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;box-sizing:border-box;outline:0;border-radius:var(--mat-menu-container-shape);background-color:var(--mat-menu-container-color);will-change:transform,opacity}.mat-mdc-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-mdc-menu-panel{outline:solid 1px}.mat-divider{color:var(--mat-menu-divider-color);margin-bottom:var(--mat-menu-divider-bottom-spacing);margin-top:var(--mat-menu-divider-top-spacing)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:var(--mat-menu-item-leading-spacing);padding-right:var(--mat-menu-item-trailing-spacing);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;align-items:center;min-height:48px}.mat-mdc-menu-item:focus{outline:none}[dir=rtl] .mat-mdc-menu-item,.mat-mdc-menu-item[dir=rtl]{padding-left:var(--mat-menu-item-trailing-spacing);padding-right:var(--mat-menu-item-leading-spacing)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing);padding-right:var(--mat-menu-item-with-icon-trailing-spacing)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]),.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon])[dir=rtl]{padding-left:var(--mat-menu-item-with-icon-trailing-spacing);padding-right:var(--mat-menu-item-with-icon-leading-spacing)}.mat-mdc-menu-item::-moz-focus-inner{border:0}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color)}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color)}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing);height:var(--mat-menu-item-icon-size);width:var(--mat-menu-item-icon-size)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color)}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color)}.cdk-high-contrast-active .mat-mdc-menu-item{margin-top:1px}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing)}[dir=rtl] .mat-mdc-menu-submenu-icon{right:auto;padding-right:var(--mat-menu-item-spacing);padding-left:0}.cdk-high-contrast-active .mat-mdc-menu-submenu-icon{fill:CanvasText}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}',
        ],
        encapsulation: 2,
        data: { animation: [_t.transformMenu, _t.fadeInItems] },
        changeDetection: 0,
      }));
    let r = e;
    return r;
  })(),
  er = new Le("mat-menu-scroll-strategy", {
    providedIn: "root",
    factory: () => {
      let r = N(ht);
      return () => r.scrollStrategies.reposition();
    },
  });
var Gn = Tn({ passive: !0 });
var Zn = (() => {
  let e = class e {
    get _deprecatedMatMenuTriggerFor() {
      return this.menu;
    }
    set _deprecatedMatMenuTriggerFor(i) {
      this.menu = i;
    }
    get menu() {
      return this._menu;
    }
    set menu(i) {
      i !== this._menu &&
        ((this._menu = i),
        this._menuCloseSubscription.unsubscribe(),
        i &&
          (this._parentMaterialMenu,
          (this._menuCloseSubscription = i.close.subscribe((n) => {
            this._destroyMenu(n),
              (n === "click" || n === "tab") &&
                this._parentMaterialMenu &&
                this._parentMaterialMenu.closed.emit(n);
          }))),
        this._menuItemInstance?._setTriggersSubmenu(this.triggersSubmenu()));
    }
    constructor(i, n, s, o, a, l, c, m, u) {
      (this._overlay = i),
        (this._element = n),
        (this._viewContainerRef = s),
        (this._menuItemInstance = l),
        (this._dir = c),
        (this._focusMonitor = m),
        (this._ngZone = u),
        (this._overlayRef = null),
        (this._menuOpen = !1),
        (this._closingActionsSubscription = et.EMPTY),
        (this._hoverSubscription = et.EMPTY),
        (this._menuCloseSubscription = et.EMPTY),
        (this._changeDetectorRef = N(qe)),
        (this._handleTouchStart = (_) => {
          Dn(_) || (this._openedBy = "touch");
        }),
        (this._openedBy = void 0),
        (this.restoreFocus = !0),
        (this.menuOpened = new ot()),
        (this.onMenuOpen = this.menuOpened),
        (this.menuClosed = new ot()),
        (this.onMenuClose = this.menuClosed),
        (this._scrollStrategy = o),
        (this._parentMaterialMenu = a instanceof ke ? a : void 0),
        n.nativeElement.addEventListener(
          "touchstart",
          this._handleTouchStart,
          Gn,
        );
    }
    ngAfterContentInit() {
      this._handleHover();
    }
    ngOnDestroy() {
      this._overlayRef &&
        (this._overlayRef.dispose(), (this._overlayRef = null)),
        this._element.nativeElement.removeEventListener(
          "touchstart",
          this._handleTouchStart,
          Gn,
        ),
        this._menuCloseSubscription.unsubscribe(),
        this._closingActionsSubscription.unsubscribe(),
        this._hoverSubscription.unsubscribe();
    }
    get menuOpen() {
      return this._menuOpen;
    }
    get dir() {
      return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
    }
    triggersSubmenu() {
      return !!(
        this._menuItemInstance &&
        this._parentMaterialMenu &&
        this.menu
      );
    }
    toggleMenu() {
      return this._menuOpen ? this.closeMenu() : this.openMenu();
    }
    openMenu() {
      let i = this.menu;
      if (this._menuOpen || !i) return;
      let n = this._createOverlay(i),
        s = n.getConfig(),
        o = s.positionStrategy;
      this._setPosition(i, o),
        (s.hasBackdrop =
          i.hasBackdrop == null ? !this.triggersSubmenu() : i.hasBackdrop),
        n.attach(this._getPortal(i)),
        i.lazyContent && i.lazyContent.attach(this.menuData),
        (this._closingActionsSubscription =
          this._menuClosingActions().subscribe(() => this.closeMenu())),
        this._initMenu(i),
        i instanceof ke &&
          (i._startAnimation(),
          i._directDescendantItems.changes.pipe(rt(i.close)).subscribe(() => {
            o.withLockedPosition(!1).reapplyLastPosition(),
              o.withLockedPosition(!0);
          }));
    }
    closeMenu() {
      this.menu?.close.emit();
    }
    focus(i, n) {
      this._focusMonitor && i
        ? this._focusMonitor.focusVia(this._element, i, n)
        : this._element.nativeElement.focus(n);
    }
    updatePosition() {
      this._overlayRef?.updatePosition();
    }
    _destroyMenu(i) {
      if (!this._overlayRef || !this.menuOpen) return;
      let n = this.menu;
      this._closingActionsSubscription.unsubscribe(),
        this._overlayRef.detach(),
        this.restoreFocus &&
          (i === "keydown" || !this._openedBy || !this.triggersSubmenu()) &&
          this.focus(this._openedBy),
        (this._openedBy = void 0),
        n instanceof ke
          ? (n._resetAnimation(),
            n.lazyContent
              ? n._animationDone
                  .pipe(
                    Oe((s) => s.toState === "void"),
                    nt(1),
                    rt(n.lazyContent._attached),
                  )
                  .subscribe({
                    next: () => n.lazyContent.detach(),
                    complete: () => this._setIsMenuOpen(!1),
                  })
              : this._setIsMenuOpen(!1))
          : (this._setIsMenuOpen(!1), n?.lazyContent?.detach());
    }
    _initMenu(i) {
      (i.parentMenu = this.triggersSubmenu()
        ? this._parentMaterialMenu
        : void 0),
        (i.direction = this.dir),
        this._setMenuElevation(i),
        i.focusFirstItem(this._openedBy || "program"),
        this._setIsMenuOpen(!0);
    }
    _setMenuElevation(i) {
      if (i.setElevation) {
        let n = 0,
          s = i.parentMenu;
        for (; s; ) n++, (s = s.parentMenu);
        i.setElevation(n);
      }
    }
    _setIsMenuOpen(i) {
      i !== this._menuOpen &&
        ((this._menuOpen = i),
        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit(),
        this.triggersSubmenu() && this._menuItemInstance._setHighlighted(i),
        this._changeDetectorRef.markForCheck());
    }
    _createOverlay(i) {
      if (!this._overlayRef) {
        let n = this._getOverlayConfig(i);
        this._subscribeToPositions(i, n.positionStrategy),
          (this._overlayRef = this._overlay.create(n)),
          this._overlayRef.keydownEvents().subscribe();
      }
      return this._overlayRef;
    }
    _getOverlayConfig(i) {
      return new On({
        positionStrategy: this._overlay
          .position()
          .flexibleConnectedTo(this._element)
          .withLockedPosition()
          .withGrowAfterOpen()
          .withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"),
        backdropClass: i.backdropClass || "cdk-overlay-transparent-backdrop",
        panelClass: i.overlayPanelClass,
        scrollStrategy: this._scrollStrategy(),
        direction: this._dir,
      });
    }
    _subscribeToPositions(i, n) {
      i.setPositionClasses &&
        n.positionChanges.subscribe((s) => {
          let o = s.connectionPair.overlayX === "start" ? "after" : "before",
            a = s.connectionPair.overlayY === "top" ? "below" : "above";
          this._ngZone
            ? this._ngZone.run(() => i.setPositionClasses(o, a))
            : i.setPositionClasses(o, a);
        });
    }
    _setPosition(i, n) {
      let [s, o] =
          i.xPosition === "before" ? ["end", "start"] : ["start", "end"],
        [a, l] =
          i.yPosition === "above" ? ["bottom", "top"] : ["top", "bottom"],
        [c, m] = [a, l],
        [u, _] = [s, o],
        g = 0;
      if (this.triggersSubmenu()) {
        if (
          ((_ = s = i.xPosition === "before" ? "start" : "end"),
          (o = u = s === "end" ? "start" : "end"),
          this._parentMaterialMenu)
        ) {
          if (this._parentInnerPadding == null) {
            let h = this._parentMaterialMenu.items.first;
            this._parentInnerPadding = h ? h._getHostElement().offsetTop : 0;
          }
          g =
            a === "bottom"
              ? this._parentInnerPadding
              : -this._parentInnerPadding;
        }
      } else
        i.overlapTrigger ||
          ((c = a === "top" ? "bottom" : "top"),
          (m = l === "top" ? "bottom" : "top"));
      n.withPositions([
        { originX: s, originY: c, overlayX: u, overlayY: a, offsetY: g },
        { originX: o, originY: c, overlayX: _, overlayY: a, offsetY: g },
        { originX: s, originY: m, overlayX: u, overlayY: l, offsetY: -g },
        { originX: o, originY: m, overlayX: _, overlayY: l, offsetY: -g },
      ]);
    }
    _menuClosingActions() {
      let i = this._overlayRef.backdropClick(),
        n = this._overlayRef.detachments(),
        s = this._parentMaterialMenu ? this._parentMaterialMenu.closed : jt(),
        o = this._parentMaterialMenu
          ? this._parentMaterialMenu._hovered().pipe(
              Oe((a) => a !== this._menuItemInstance),
              Oe(() => this._menuOpen),
            )
          : jt();
      return it(i, s, o, n);
    }
    _handleMousedown(i) {
      In(i) ||
        ((this._openedBy = i.button === 0 ? "mouse" : void 0),
        this.triggersSubmenu() && i.preventDefault());
    }
    _handleKeydown(i) {
      let n = i.keyCode;
      (n === 13 || n === 32) && (this._openedBy = "keyboard"),
        this.triggersSubmenu() &&
          ((n === 39 && this.dir === "ltr") ||
            (n === 37 && this.dir === "rtl")) &&
          ((this._openedBy = "keyboard"), this.openMenu());
    }
    _handleClick(i) {
      this.triggersSubmenu()
        ? (i.stopPropagation(), this.openMenu())
        : this.toggleMenu();
    }
    _handleHover() {
      !this.triggersSubmenu() ||
        !this._parentMaterialMenu ||
        (this._hoverSubscription = this._parentMaterialMenu
          ._hovered()
          .pipe(
            Oe((i) => i === this._menuItemInstance && !i.disabled),
            Kt(0, Bt),
          )
          .subscribe(() => {
            (this._openedBy = "mouse"),
              this.menu instanceof ke && this.menu._isAnimating
                ? this.menu._animationDone
                    .pipe(
                      nt(1),
                      Kt(0, Bt),
                      rt(this._parentMaterialMenu._hovered()),
                    )
                    .subscribe(() => this.openMenu())
                : this.openMenu();
          }));
    }
    _getPortal(i) {
      return (
        (!this._portal || this._portal.templateRef !== i.templateRef) &&
          (this._portal = new Rn(i.templateRef, this._viewContainerRef)),
        this._portal
      );
    }
  };
  (e.ɵfac = function (n) {
    return new (n || e)(
      S(ht),
      S(H),
      S(Hi),
      S(er),
      S(ii, 8),
      S(Qe, 10),
      S(kn, 8),
      S(Yt),
      S(he),
    );
  }),
    (e.ɵdir = Ae({
      type: e,
      selectors: [
        ["", "mat-menu-trigger-for", ""],
        ["", "matMenuTriggerFor", ""],
      ],
      hostAttrs: [1, "mat-mdc-menu-trigger"],
      hostVars: 3,
      hostBindings: function (n, s) {
        n & 1 &&
          fe("click", function (a) {
            return s._handleClick(a);
          })("mousedown", function (a) {
            return s._handleMousedown(a);
          })("keydown", function (a) {
            return s._handleKeydown(a);
          }),
          n & 2 &&
            je("aria-haspopup", s.menu ? "menu" : null)(
              "aria-expanded",
              s.menuOpen,
            )("aria-controls", s.menuOpen ? s.menu.panelId : null);
      },
      inputs: {
        _deprecatedMatMenuTriggerFor: [
          w.None,
          "mat-menu-trigger-for",
          "_deprecatedMatMenuTriggerFor",
        ],
        menu: [w.None, "matMenuTriggerFor", "menu"],
        menuData: [w.None, "matMenuTriggerData", "menuData"],
        restoreFocus: [w.None, "matMenuTriggerRestoreFocus", "restoreFocus"],
      },
      outputs: {
        menuOpened: "menuOpened",
        onMenuOpen: "onMenuOpen",
        menuClosed: "menuClosed",
        onMenuClose: "onMenuClose",
      },
      exportAs: ["matMenuTrigger"],
      standalone: !0,
    }));
  let r = e;
  return r;
})();
var tr = ["*", [["mat-toolbar-row"]]],
  ir = ["*", "mat-toolbar-row"],
  nr = (() => {
    let e = class e {};
    (e.ɵfac = function (n) {
      return new (n || e)();
    }),
      (e.ɵdir = Ae({
        type: e,
        selectors: [["mat-toolbar-row"]],
        hostAttrs: [1, "mat-toolbar-row"],
        exportAs: ["matToolbarRow"],
        standalone: !0,
      }));
    let r = e;
    return r;
  })(),
  Jn = (() => {
    let e = class e {
      constructor(i, n, s) {
        (this._elementRef = i), (this._platform = n), (this._document = s);
      }
      ngAfterViewInit() {
        this._platform.isBrowser &&
          (this._checkToolbarMixedModes(),
          this._toolbarRows.changes.subscribe(() =>
            this._checkToolbarMixedModes(),
          ));
      }
      _checkToolbarMixedModes() {
        this._toolbarRows.length;
      }
    };
    (e.ɵfac = function (n) {
      return new (n || e)(S(H), S(wn), S(le));
    }),
      (e.ɵcmp = L({
        type: e,
        selectors: [["mat-toolbar"]],
        contentQueries: function (n, s, o) {
          if ((n & 1 && Ie(o, nr, 5), n & 2)) {
            let a;
            ge((a = ye())) && (s._toolbarRows = a);
          }
        },
        hostAttrs: [1, "mat-toolbar"],
        hostVars: 6,
        hostBindings: function (n, s) {
          n & 2 &&
            (Wi(s.color ? "mat-" + s.color : ""),
            Pe("mat-toolbar-multiple-rows", s._toolbarRows.length > 0)(
              "mat-toolbar-single-row",
              s._toolbarRows.length === 0,
            ));
        },
        inputs: { color: "color" },
        exportAs: ["matToolbar"],
        standalone: !0,
        features: [z],
        ngContentSelectors: ir,
        decls: 2,
        vars: 0,
        template: function (n, s) {
          n & 1 && (Ve(tr), pe(0), pe(1, 1));
        },
        styles: [
          ".mat-toolbar{background:var(--mat-toolbar-container-background-color);color:var(--mat-toolbar-container-text-color)}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font-family:var(--mat-toolbar-title-text-font);font-size:var(--mat-toolbar-title-text-size);line-height:var(--mat-toolbar-title-text-line-height);font-weight:var(--mat-toolbar-title-text-weight);letter-spacing:var(--mat-toolbar-title-text-tracking);margin:0}.cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar .mat-mdc-button-base.mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color:var(--mat-toolbar-container-text-color);--mdc-outlined-button-label-text-color:var(--mat-toolbar-container-text-color)}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap;height:var(--mat-toolbar-standard-height)}@media(max-width: 599px){.mat-toolbar-row,.mat-toolbar-single-row{height:var(--mat-toolbar-mobile-height)}}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%;min-height:var(--mat-toolbar-standard-height)}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:var(--mat-toolbar-mobile-height)}}",
        ],
        encapsulation: 2,
        changeDetection: 0,
      }));
    let r = e;
    return r;
  })();
var es = (() => {
  let e = class e {
    constructor() {
      this.totalInCart = N(lt).totalInCart;
    }
  };
  (e.ɵfac = function (n) {
    return new (n || e)();
  }),
    (e.ɵcmp = L({
      type: e,
      selectors: [["app-header"]],
      standalone: !0,
      features: [z],
      decls: 16,
      vars: 2,
      consts: [
        ["menu", "matMenu"],
        ["color", "accent"],
        ["routerLink", "/", "matTooltip", "Open main page", 1, "home-link"],
        [1, "d-flex", "flex-fill"],
        [
          "matTooltip",
          "Open account menu",
          "mat-icon-button",
          "",
          3,
          "matMenuTriggerFor",
        ],
        [
          "routerLink",
          "cart",
          "matTooltip",
          "Go to cart",
          "mat-icon-button",
          "",
        ],
        ["matBadgeColor", "accent", 3, "matBadge"],
        ["routerLink", "admin/orders", "mat-menu-item", ""],
        ["routerLink", "admin/products", "mat-menu-item", ""],
      ],
      template: function (n, s) {
        if (
          (n & 1 &&
            (C(0, "mat-toolbar", 1)(1, "a", 2),
            Z(2, "E-shop"),
            A(),
            Q(3, "div", 3),
            C(4, "button", 4)(5, "mat-icon"),
            Z(6, "account_circle"),
            A()(),
            C(7, "button", 5)(8, "mat-icon", 6),
            Z(9, "shopping_cart"),
            A()()(),
            C(10, "mat-menu", null, 0)(12, "a", 7),
            Z(13, "Manage orders"),
            A(),
            C(14, "a", 8),
            Z(15, "Manage products"),
            A()()),
          n & 2)
        ) {
          let o = tn(11);
          j(4), W("matMenuTriggerFor", o), j(4), W("matBadge", s.totalInCart());
        }
      },
      dependencies: [Jn, bn, pt, ft, Zn, ct, Wn, ke, Qe],
      styles: [
        "a.mat-menu-item[_ngcontent-%COMP%]{text-decoration:none;color:#000}.home-link[_ngcontent-%COMP%]{color:#fff;text-decoration:none}",
      ],
      changeDetection: 0,
    }));
  let r = e;
  return r;
})();
var ts = (() => {
  let e = class e {};
  (e.ɵfac = function (n) {
    return new (n || e)();
  }),
    (e.ɵcmp = L({
      type: e,
      selectors: [["app-root"]],
      standalone: !0,
      features: [z],
      decls: 3,
      vars: 0,
      consts: [[1, "container", "py-3", "py-md-5"]],
      template: function (n, s) {
        n & 1 &&
          (Q(0, "app-header"), C(1, "div", 0), Q(2, "router-outlet"), A());
      },
      dependencies: [es, vn],
      changeDetection: 0,
    }));
  let r = e;
  return r;
})();
function is(r) {
  return new E(3e3, !1);
}
function sr() {
  return new E(3100, !1);
}
function rr() {
  return new E(3101, !1);
}
function or(r) {
  return new E(3001, !1);
}
function ar(r) {
  return new E(3003, !1);
}
function lr(r) {
  return new E(3004, !1);
}
function cr(r, e) {
  return new E(3005, !1);
}
function mr() {
  return new E(3006, !1);
}
function ur() {
  return new E(3007, !1);
}
function dr(r, e) {
  return new E(3008, !1);
}
function hr(r) {
  return new E(3002, !1);
}
function fr(r, e, t, i, n) {
  return new E(3010, !1);
}
function pr() {
  return new E(3011, !1);
}
function gr() {
  return new E(3012, !1);
}
function yr() {
  return new E(3200, !1);
}
function _r() {
  return new E(3202, !1);
}
function vr() {
  return new E(3013, !1);
}
function br(r) {
  return new E(3014, !1);
}
function Er(r) {
  return new E(3015, !1);
}
function Sr(r) {
  return new E(3016, !1);
}
function wr(r, e) {
  return new E(3404, !1);
}
function Tr(r) {
  return new E(3502, !1);
}
function Mr(r) {
  return new E(3503, !1);
}
function Cr() {
  return new E(3300, !1);
}
function Ar(r) {
  return new E(3504, !1);
}
function Pr(r) {
  return new E(3301, !1);
}
function Ir(r, e) {
  return new E(3302, !1);
}
function Dr(r) {
  return new E(3303, !1);
}
function kr(r, e) {
  return new E(3400, !1);
}
function Nr(r) {
  return new E(3401, !1);
}
function Rr(r) {
  return new E(3402, !1);
}
function Fr(r, e) {
  return new E(3505, !1);
}
function ce(r) {
  switch (r.length) {
    case 0:
      return new De();
    case 1:
      return r[0];
    default:
      return new Jt(r);
  }
}
function gs(r, e, t = new Map(), i = new Map()) {
  let n = [],
    s = [],
    o = -1,
    a = null;
  if (
    (e.forEach((l) => {
      let c = l.get("offset"),
        m = c == o,
        u = (m && a) || new Map();
      l.forEach((_, g) => {
        let h = g,
          y = _;
        if (g !== "offset")
          switch (((h = r.normalizePropertyName(h, n)), y)) {
            case dt:
              y = t.get(g);
              break;
            case J:
              y = i.get(g);
              break;
            default:
              y = r.normalizeStyleValue(g, h, y, n);
              break;
          }
        u.set(h, y);
      }),
        m || s.push(u),
        (a = u),
        (o = c);
    }),
    n.length)
  )
    throw Tr(n);
  return s;
}
function Mi(r, e, t, i) {
  switch (e) {
    case "start":
      r.onStart(() => i(t && ni(t, "start", r)));
      break;
    case "done":
      r.onDone(() => i(t && ni(t, "done", r)));
      break;
    case "destroy":
      r.onDestroy(() => i(t && ni(t, "destroy", r)));
      break;
  }
}
function ni(r, e, t) {
  let i = t.totalTime,
    n = !!t.disabled,
    s = Ci(
      r.element,
      r.triggerName,
      r.fromState,
      r.toState,
      e || r.phaseName,
      i ?? r.totalTime,
      n,
    ),
    o = r._data;
  return o != null && (s._data = o), s;
}
function Ci(r, e, t, i, n = "", s = 0, o) {
  return {
    element: r,
    triggerName: e,
    fromState: t,
    toState: i,
    phaseName: n,
    totalTime: s,
    disabled: !!o,
  };
}
function V(r, e, t) {
  let i = r.get(e);
  return i || r.set(e, (i = t)), i;
}
function ns(r) {
  let e = r.indexOf(":"),
    t = r.substring(1, e),
    i = r.slice(e + 1);
  return [t, i];
}
var Or = typeof document > "u" ? null : document.documentElement;
function Ai(r) {
  let e = r.parentNode || r.host || null;
  return e === Or ? null : e;
}
function Lr(r) {
  return r.substring(1, 6) == "ebkit";
}
var _e = null,
  ss = !1;
function zr(r) {
  _e ||
    ((_e = xr() || {}), (ss = _e.style ? "WebkitAppearance" in _e.style : !1));
  let e = !0;
  return (
    _e.style &&
      !Lr(r) &&
      ((e = r in _e.style),
      !e &&
        ss &&
        (e = "Webkit" + r.charAt(0).toUpperCase() + r.slice(1) in _e.style)),
    e
  );
}
function xr() {
  return typeof document < "u" ? document.body : null;
}
function ys(r, e) {
  for (; e; ) {
    if (e === r) return !0;
    e = Ai(e);
  }
  return !1;
}
function _s(r, e, t) {
  if (t) return Array.from(r.querySelectorAll(e));
  let i = r.querySelector(e);
  return i ? [i] : [];
}
var Pi = (() => {
    let e = class e {
      validateStyleProperty(i) {
        return zr(i);
      }
      matchesElement(i, n) {
        return !1;
      }
      containsElement(i, n) {
        return ys(i, n);
      }
      getParentElement(i) {
        return Ai(i);
      }
      query(i, n, s) {
        return _s(i, n, s);
      }
      computeStyle(i, n, s) {
        return s || "";
      }
      animate(i, n, s, o, a, l = [], c) {
        return new De(s, o);
      }
    };
    (e.ɵfac = function (n) {
      return new (n || e)();
    }),
      (e.ɵprov = Me({ token: e, factory: e.ɵfac }));
    let r = e;
    return r;
  })(),
  Ni = class Ni {};
Ni.NOOP = new Pi();
var Ee = Ni,
  Se = class {};
var Br = 1e3,
  vs = "{{",
  jr = "}}",
  bs = "ng-enter",
  ci = "ng-leave",
  vt = "ng-trigger",
  Tt = ".ng-trigger",
  rs = "ng-animating",
  mi = ".ng-animating";
function oe(r) {
  if (typeof r == "number") return r;
  let e = r.match(/^(-?[\.\d]+)(m?s)/);
  return !e || e.length < 2 ? 0 : ui(parseFloat(e[1]), e[2]);
}
function ui(r, e) {
  switch (e) {
    case "s":
      return r * Br;
    default:
      return r;
  }
}
function Mt(r, e, t) {
  return r.hasOwnProperty("duration") ? r : Kr(r, e, t);
}
function Kr(r, e, t) {
  let i =
      /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i,
    n,
    s = 0,
    o = "";
  if (typeof r == "string") {
    let a = r.match(i);
    if (a === null) return e.push(is(r)), { duration: 0, delay: 0, easing: "" };
    n = ui(parseFloat(a[1]), a[2]);
    let l = a[3];
    l != null && (s = ui(parseFloat(l), a[4]));
    let c = a[5];
    c && (o = c);
  } else n = r;
  if (!t) {
    let a = !1,
      l = e.length;
    n < 0 && (e.push(sr()), (a = !0)),
      s < 0 && (e.push(rr()), (a = !0)),
      a && e.splice(l, 0, is(r));
  }
  return { duration: n, delay: s, easing: o };
}
function Vr(r) {
  return r.length
    ? r[0] instanceof Map
      ? r
      : r.map((e) => new Map(Object.entries(e)))
    : [];
}
function ee(r, e, t) {
  e.forEach((i, n) => {
    let s = Ii(n);
    t && !t.has(n) && t.set(n, r.style[s]), (r.style[s] = i);
  });
}
function be(r, e) {
  e.forEach((t, i) => {
    let n = Ii(i);
    r.style[n] = "";
  });
}
function $e(r) {
  return Array.isArray(r) ? (r.length == 1 ? r[0] : Fn(r)) : r;
}
function qr(r, e, t) {
  let i = e.params || {},
    n = Es(r);
  n.length &&
    n.forEach((s) => {
      i.hasOwnProperty(s) || t.push(or(s));
    });
}
var di = new RegExp(`${vs}\\s*(.+?)\\s*${jr}`, "g");
function Es(r) {
  let e = [];
  if (typeof r == "string") {
    let t;
    for (; (t = di.exec(r)); ) e.push(t[1]);
    di.lastIndex = 0;
  }
  return e;
}
function He(r, e, t) {
  let i = `${r}`,
    n = i.replace(di, (s, o) => {
      let a = e[o];
      return a == null && (t.push(ar(o)), (a = "")), a.toString();
    });
  return n == i ? r : n;
}
var Qr = /-+([a-z0-9])/g;
function Ii(r) {
  return r.replace(Qr, (...e) => e[1].toUpperCase());
}
function $r(r, e) {
  return r === 0 || e === 0;
}
function Ur(r, e, t) {
  if (t.size && e.length) {
    let i = e[0],
      n = [];
    if (
      (t.forEach((s, o) => {
        i.has(o) || n.push(o), i.set(o, s);
      }),
      n.length)
    )
      for (let s = 1; s < e.length; s++) {
        let o = e[s];
        n.forEach((a) => o.set(a, Di(r, a)));
      }
  }
  return e;
}
function K(r, e, t) {
  switch (e.type) {
    case v.Trigger:
      return r.visitTrigger(e, t);
    case v.State:
      return r.visitState(e, t);
    case v.Transition:
      return r.visitTransition(e, t);
    case v.Sequence:
      return r.visitSequence(e, t);
    case v.Group:
      return r.visitGroup(e, t);
    case v.Animate:
      return r.visitAnimate(e, t);
    case v.Keyframes:
      return r.visitKeyframes(e, t);
    case v.Style:
      return r.visitStyle(e, t);
    case v.Reference:
      return r.visitReference(e, t);
    case v.AnimateChild:
      return r.visitAnimateChild(e, t);
    case v.AnimateRef:
      return r.visitAnimateRef(e, t);
    case v.Query:
      return r.visitQuery(e, t);
    case v.Stagger:
      return r.visitStagger(e, t);
    default:
      throw lr(e.type);
  }
}
function Di(r, e) {
  return window.getComputedStyle(r)[e];
}
var Hr = new Set([
    "width",
    "height",
    "minWidth",
    "minHeight",
    "maxWidth",
    "maxHeight",
    "left",
    "top",
    "bottom",
    "right",
    "fontSize",
    "outlineWidth",
    "outlineOffset",
    "paddingTop",
    "paddingLeft",
    "paddingBottom",
    "paddingRight",
    "marginTop",
    "marginLeft",
    "marginBottom",
    "marginRight",
    "borderRadius",
    "borderWidth",
    "borderTopWidth",
    "borderLeftWidth",
    "borderRightWidth",
    "borderBottomWidth",
    "textIndent",
    "perspective",
  ]),
  Ct = class extends Se {
    normalizePropertyName(e, t) {
      return Ii(e);
    }
    normalizeStyleValue(e, t, i, n) {
      let s = "",
        o = i.toString().trim();
      if (Hr.has(t) && i !== 0 && i !== "0")
        if (typeof i == "number") s = "px";
        else {
          let a = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
          a && a[1].length == 0 && n.push(cr(e, i));
        }
      return o + s;
    }
  };
var At = "*";
function Wr(r, e) {
  let t = [];
  return (
    typeof r == "string"
      ? r.split(/\s*,\s*/).forEach((i) => Gr(i, t, e))
      : t.push(r),
    t
  );
}
function Gr(r, e, t) {
  if (r[0] == ":") {
    let l = Yr(r, t);
    if (typeof l == "function") {
      e.push(l);
      return;
    }
    r = l;
  }
  let i = r.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
  if (i == null || i.length < 4) return t.push(Er(r)), e;
  let n = i[1],
    s = i[2],
    o = i[3];
  e.push(os(n, o));
  let a = n == At && o == At;
  s[0] == "<" && !a && e.push(os(o, n));
}
function Yr(r, e) {
  switch (r) {
    case ":enter":
      return "void => *";
    case ":leave":
      return "* => void";
    case ":increment":
      return (t, i) => parseFloat(i) > parseFloat(t);
    case ":decrement":
      return (t, i) => parseFloat(i) < parseFloat(t);
    default:
      return e.push(Sr(r)), "* => *";
  }
}
var bt = new Set(["true", "1"]),
  Et = new Set(["false", "0"]);
function os(r, e) {
  let t = bt.has(r) || Et.has(r),
    i = bt.has(e) || Et.has(e);
  return (n, s) => {
    let o = r == At || r == n,
      a = e == At || e == s;
    return (
      !o && t && typeof n == "boolean" && (o = n ? bt.has(r) : Et.has(r)),
      !a && i && typeof s == "boolean" && (a = s ? bt.has(e) : Et.has(e)),
      o && a
    );
  };
}
var Ss = ":self",
  Xr = new RegExp(`s*${Ss}s*,?`, "g");
function ws(r, e, t, i) {
  return new hi(r).build(e, t, i);
}
var as = "",
  hi = class {
    constructor(e) {
      this._driver = e;
    }
    build(e, t, i) {
      let n = new fi(t);
      return this._resetContextStyleTimingState(n), K(this, $e(e), n);
    }
    _resetContextStyleTimingState(e) {
      (e.currentQuerySelector = as),
        (e.collectedStyles = new Map()),
        e.collectedStyles.set(as, new Map()),
        (e.currentTime = 0);
    }
    visitTrigger(e, t) {
      let i = (t.queryCount = 0),
        n = (t.depCount = 0),
        s = [],
        o = [];
      return (
        e.name.charAt(0) == "@" && t.errors.push(mr()),
        e.definitions.forEach((a) => {
          if ((this._resetContextStyleTimingState(t), a.type == v.State)) {
            let l = a,
              c = l.name;
            c
              .toString()
              .split(/\s*,\s*/)
              .forEach((m) => {
                (l.name = m), s.push(this.visitState(l, t));
              }),
              (l.name = c);
          } else if (a.type == v.Transition) {
            let l = this.visitTransition(a, t);
            (i += l.queryCount), (n += l.depCount), o.push(l);
          } else t.errors.push(ur());
        }),
        {
          type: v.Trigger,
          name: e.name,
          states: s,
          transitions: o,
          queryCount: i,
          depCount: n,
          options: null,
        }
      );
    }
    visitState(e, t) {
      let i = this.visitStyle(e.styles, t),
        n = (e.options && e.options.params) || null;
      if (i.containsDynamicStyles) {
        let s = new Set(),
          o = n || {};
        i.styles.forEach((a) => {
          a instanceof Map &&
            a.forEach((l) => {
              Es(l).forEach((c) => {
                o.hasOwnProperty(c) || s.add(c);
              });
            });
        }),
          s.size && t.errors.push(dr(e.name, [...s.values()]));
      }
      return {
        type: v.State,
        name: e.name,
        style: i,
        options: n ? { params: n } : null,
      };
    }
    visitTransition(e, t) {
      (t.queryCount = 0), (t.depCount = 0);
      let i = K(this, $e(e.animation), t),
        n = Wr(e.expr, t.errors);
      return {
        type: v.Transition,
        matchers: n,
        animation: i,
        queryCount: t.queryCount,
        depCount: t.depCount,
        options: ve(e.options),
      };
    }
    visitSequence(e, t) {
      return {
        type: v.Sequence,
        steps: e.steps.map((i) => K(this, i, t)),
        options: ve(e.options),
      };
    }
    visitGroup(e, t) {
      let i = t.currentTime,
        n = 0,
        s = e.steps.map((o) => {
          t.currentTime = i;
          let a = K(this, o, t);
          return (n = Math.max(n, t.currentTime)), a;
        });
      return (
        (t.currentTime = n), { type: v.Group, steps: s, options: ve(e.options) }
      );
    }
    visitAnimate(e, t) {
      let i = to(e.timings, t.errors);
      t.currentAnimateTimings = i;
      let n,
        s = e.styles ? e.styles : se({});
      if (s.type == v.Keyframes) n = this.visitKeyframes(s, t);
      else {
        let o = e.styles,
          a = !1;
        if (!o) {
          a = !0;
          let c = {};
          i.easing && (c.easing = i.easing), (o = se(c));
        }
        t.currentTime += i.duration + i.delay;
        let l = this.visitStyle(o, t);
        (l.isEmptyStep = a), (n = l);
      }
      return (
        (t.currentAnimateTimings = null),
        { type: v.Animate, timings: i, style: n, options: null }
      );
    }
    visitStyle(e, t) {
      let i = this._makeStyleAst(e, t);
      return this._validateStyleAst(i, t), i;
    }
    _makeStyleAst(e, t) {
      let i = [],
        n = Array.isArray(e.styles) ? e.styles : [e.styles];
      for (let a of n)
        typeof a == "string"
          ? a === J
            ? i.push(a)
            : t.errors.push(hr(a))
          : i.push(new Map(Object.entries(a)));
      let s = !1,
        o = null;
      return (
        i.forEach((a) => {
          if (
            a instanceof Map &&
            (a.has("easing") && ((o = a.get("easing")), a.delete("easing")), !s)
          ) {
            for (let l of a.values())
              if (l.toString().indexOf(vs) >= 0) {
                s = !0;
                break;
              }
          }
        }),
        {
          type: v.Style,
          styles: i,
          easing: o,
          offset: e.offset,
          containsDynamicStyles: s,
          options: null,
        }
      );
    }
    _validateStyleAst(e, t) {
      let i = t.currentAnimateTimings,
        n = t.currentTime,
        s = t.currentTime;
      i && s > 0 && (s -= i.duration + i.delay),
        e.styles.forEach((o) => {
          typeof o != "string" &&
            o.forEach((a, l) => {
              let c = t.collectedStyles.get(t.currentQuerySelector),
                m = c.get(l),
                u = !0;
              m &&
                (s != n &&
                  s >= m.startTime &&
                  n <= m.endTime &&
                  (t.errors.push(fr(l, m.startTime, m.endTime, s, n)),
                  (u = !1)),
                (s = m.startTime)),
                u && c.set(l, { startTime: s, endTime: n }),
                t.options && qr(a, t.options, t.errors);
            });
        });
    }
    visitKeyframes(e, t) {
      let i = { type: v.Keyframes, styles: [], options: null };
      if (!t.currentAnimateTimings) return t.errors.push(pr()), i;
      let n = 1,
        s = 0,
        o = [],
        a = !1,
        l = !1,
        c = 0,
        m = e.steps.map((P) => {
          let I = this._makeStyleAst(P, t),
            F = I.offset != null ? I.offset : eo(I.styles),
            k = 0;
          return (
            F != null && (s++, (k = I.offset = F)),
            (l = l || k < 0 || k > 1),
            (a = a || k < c),
            (c = k),
            o.push(k),
            I
          );
        });
      l && t.errors.push(gr()), a && t.errors.push(yr());
      let u = e.steps.length,
        _ = 0;
      s > 0 && s < u ? t.errors.push(_r()) : s == 0 && (_ = n / (u - 1));
      let g = u - 1,
        h = t.currentTime,
        y = t.currentAnimateTimings,
        T = y.duration;
      return (
        m.forEach((P, I) => {
          let F = _ > 0 ? (I == g ? 1 : _ * I) : o[I],
            k = F * T;
          (t.currentTime = h + y.delay + k),
            (y.duration = k),
            this._validateStyleAst(P, t),
            (P.offset = F),
            i.styles.push(P);
        }),
        i
      );
    }
    visitReference(e, t) {
      return {
        type: v.Reference,
        animation: K(this, $e(e.animation), t),
        options: ve(e.options),
      };
    }
    visitAnimateChild(e, t) {
      return t.depCount++, { type: v.AnimateChild, options: ve(e.options) };
    }
    visitAnimateRef(e, t) {
      return {
        type: v.AnimateRef,
        animation: this.visitReference(e.animation, t),
        options: ve(e.options),
      };
    }
    visitQuery(e, t) {
      let i = t.currentQuerySelector,
        n = e.options || {};
      t.queryCount++, (t.currentQuery = e);
      let [s, o] = Zr(e.selector);
      (t.currentQuerySelector = i.length ? i + " " + s : s),
        V(t.collectedStyles, t.currentQuerySelector, new Map());
      let a = K(this, $e(e.animation), t);
      return (
        (t.currentQuery = null),
        (t.currentQuerySelector = i),
        {
          type: v.Query,
          selector: s,
          limit: n.limit || 0,
          optional: !!n.optional,
          includeSelf: o,
          animation: a,
          originalSelector: e.selector,
          options: ve(e.options),
        }
      );
    }
    visitStagger(e, t) {
      t.currentQuery || t.errors.push(vr());
      let i =
        e.timings === "full"
          ? { duration: 0, delay: 0, easing: "full" }
          : Mt(e.timings, t.errors, !0);
      return {
        type: v.Stagger,
        animation: K(this, $e(e.animation), t),
        timings: i,
        options: null,
      };
    }
  };
function Zr(r) {
  let e = !!r.split(/\s*,\s*/).find((t) => t == Ss);
  return (
    e && (r = r.replace(Xr, "")),
    (r = r
      .replace(/@\*/g, Tt)
      .replace(/@\w+/g, (t) => Tt + "-" + t.slice(1))
      .replace(/:animating/g, mi)),
    [r, e]
  );
}
function Jr(r) {
  return r ? Ze({}, r) : null;
}
var fi = class {
  constructor(e) {
    (this.errors = e),
      (this.queryCount = 0),
      (this.depCount = 0),
      (this.currentTransition = null),
      (this.currentQuery = null),
      (this.currentQuerySelector = null),
      (this.currentAnimateTimings = null),
      (this.currentTime = 0),
      (this.collectedStyles = new Map()),
      (this.options = null),
      (this.unsupportedCSSPropertiesFound = new Set());
  }
};
function eo(r) {
  if (typeof r == "string") return null;
  let e = null;
  if (Array.isArray(r))
    r.forEach((t) => {
      if (t instanceof Map && t.has("offset")) {
        let i = t;
        (e = parseFloat(i.get("offset"))), i.delete("offset");
      }
    });
  else if (r instanceof Map && r.has("offset")) {
    let t = r;
    (e = parseFloat(t.get("offset"))), t.delete("offset");
  }
  return e;
}
function to(r, e) {
  if (r.hasOwnProperty("duration")) return r;
  if (typeof r == "number") {
    let s = Mt(r, e).duration;
    return si(s, 0, "");
  }
  let t = r;
  if (t.split(/\s+/).some((s) => s.charAt(0) == "{" && s.charAt(1) == "{")) {
    let s = si(0, 0, "");
    return (s.dynamic = !0), (s.strValue = t), s;
  }
  let n = Mt(t, e);
  return si(n.duration, n.delay, n.easing);
}
function ve(r) {
  return (
    r ? ((r = Ze({}, r)), r.params && (r.params = Jr(r.params))) : (r = {}), r
  );
}
function si(r, e, t) {
  return { duration: r, delay: e, easing: t };
}
function ki(r, e, t, i, n, s, o = null, a = !1) {
  return {
    type: 1,
    element: r,
    keyframes: e,
    preStyleProps: t,
    postStyleProps: i,
    duration: n,
    delay: s,
    totalTime: n + s,
    easing: o,
    subTimeline: a,
  };
}
var We = class {
    constructor() {
      this._map = new Map();
    }
    get(e) {
      return this._map.get(e) || [];
    }
    append(e, t) {
      let i = this._map.get(e);
      i || this._map.set(e, (i = [])), i.push(...t);
    }
    has(e) {
      return this._map.has(e);
    }
    clear() {
      this._map.clear();
    }
  },
  io = 1,
  no = ":enter",
  so = new RegExp(no, "g"),
  ro = ":leave",
  oo = new RegExp(ro, "g");
function Ts(r, e, t, i, n, s = new Map(), o = new Map(), a, l, c = []) {
  return new pi().buildKeyframes(r, e, t, i, n, s, o, a, l, c);
}
var pi = class {
    buildKeyframes(e, t, i, n, s, o, a, l, c, m = []) {
      c = c || new We();
      let u = new gi(e, t, c, n, s, m, []);
      u.options = l;
      let _ = l.delay ? oe(l.delay) : 0;
      u.currentTimeline.delayNextStep(_),
        u.currentTimeline.setStyles([o], null, u.errors, l),
        K(this, i, u);
      let g = u.timelines.filter((h) => h.containsAnimation());
      if (g.length && a.size) {
        let h;
        for (let y = g.length - 1; y >= 0; y--) {
          let T = g[y];
          if (T.element === t) {
            h = T;
            break;
          }
        }
        h &&
          !h.allowOnlyTimelineStyles() &&
          h.setStyles([a], null, u.errors, l);
      }
      return g.length
        ? g.map((h) => h.buildKeyframes())
        : [ki(t, [], [], [], 0, _, "", !1)];
    }
    visitTrigger(e, t) {}
    visitState(e, t) {}
    visitTransition(e, t) {}
    visitAnimateChild(e, t) {
      let i = t.subInstructions.get(t.element);
      if (i) {
        let n = t.createSubContext(e.options),
          s = t.currentTimeline.currentTime,
          o = this._visitSubInstructions(i, n, n.options);
        s != o && t.transformIntoNewTimeline(o);
      }
      t.previousNode = e;
    }
    visitAnimateRef(e, t) {
      let i = t.createSubContext(e.options);
      i.transformIntoNewTimeline(),
        this._applyAnimationRefDelays([e.options, e.animation.options], t, i),
        this.visitReference(e.animation, i),
        t.transformIntoNewTimeline(i.currentTimeline.currentTime),
        (t.previousNode = e);
    }
    _applyAnimationRefDelays(e, t, i) {
      for (let n of e) {
        let s = n?.delay;
        if (s) {
          let o =
            typeof s == "number" ? s : oe(He(s, n?.params ?? {}, t.errors));
          i.delayNextStep(o);
        }
      }
    }
    _visitSubInstructions(e, t, i) {
      let s = t.currentTimeline.currentTime,
        o = i.duration != null ? oe(i.duration) : null,
        a = i.delay != null ? oe(i.delay) : null;
      return (
        o !== 0 &&
          e.forEach((l) => {
            let c = t.appendInstructionToTimeline(l, o, a);
            s = Math.max(s, c.duration + c.delay);
          }),
        s
      );
    }
    visitReference(e, t) {
      t.updateOptions(e.options, !0),
        K(this, e.animation, t),
        (t.previousNode = e);
    }
    visitSequence(e, t) {
      let i = t.subContextCount,
        n = t,
        s = e.options;
      if (
        s &&
        (s.params || s.delay) &&
        ((n = t.createSubContext(s)),
        n.transformIntoNewTimeline(),
        s.delay != null)
      ) {
        n.previousNode.type == v.Style &&
          (n.currentTimeline.snapshotCurrentStyles(), (n.previousNode = Pt));
        let o = oe(s.delay);
        n.delayNextStep(o);
      }
      e.steps.length &&
        (e.steps.forEach((o) => K(this, o, n)),
        n.currentTimeline.applyStylesToKeyframe(),
        n.subContextCount > i && n.transformIntoNewTimeline()),
        (t.previousNode = e);
    }
    visitGroup(e, t) {
      let i = [],
        n = t.currentTimeline.currentTime,
        s = e.options && e.options.delay ? oe(e.options.delay) : 0;
      e.steps.forEach((o) => {
        let a = t.createSubContext(e.options);
        s && a.delayNextStep(s),
          K(this, o, a),
          (n = Math.max(n, a.currentTimeline.currentTime)),
          i.push(a.currentTimeline);
      }),
        i.forEach((o) => t.currentTimeline.mergeTimelineCollectedStyles(o)),
        t.transformIntoNewTimeline(n),
        (t.previousNode = e);
    }
    _visitTiming(e, t) {
      if (e.dynamic) {
        let i = e.strValue,
          n = t.params ? He(i, t.params, t.errors) : i;
        return Mt(n, t.errors);
      } else return { duration: e.duration, delay: e.delay, easing: e.easing };
    }
    visitAnimate(e, t) {
      let i = (t.currentAnimateTimings = this._visitTiming(e.timings, t)),
        n = t.currentTimeline;
      i.delay && (t.incrementTime(i.delay), n.snapshotCurrentStyles());
      let s = e.style;
      s.type == v.Keyframes
        ? this.visitKeyframes(s, t)
        : (t.incrementTime(i.duration),
          this.visitStyle(s, t),
          n.applyStylesToKeyframe()),
        (t.currentAnimateTimings = null),
        (t.previousNode = e);
    }
    visitStyle(e, t) {
      let i = t.currentTimeline,
        n = t.currentAnimateTimings;
      !n && i.hasCurrentStyleProperties() && i.forwardFrame();
      let s = (n && n.easing) || e.easing;
      e.isEmptyStep
        ? i.applyEmptyStep(s)
        : i.setStyles(e.styles, s, t.errors, t.options),
        (t.previousNode = e);
    }
    visitKeyframes(e, t) {
      let i = t.currentAnimateTimings,
        n = t.currentTimeline.duration,
        s = i.duration,
        a = t.createSubContext().currentTimeline;
      (a.easing = i.easing),
        e.styles.forEach((l) => {
          let c = l.offset || 0;
          a.forwardTime(c * s),
            a.setStyles(l.styles, l.easing, t.errors, t.options),
            a.applyStylesToKeyframe();
        }),
        t.currentTimeline.mergeTimelineCollectedStyles(a),
        t.transformIntoNewTimeline(n + s),
        (t.previousNode = e);
    }
    visitQuery(e, t) {
      let i = t.currentTimeline.currentTime,
        n = e.options || {},
        s = n.delay ? oe(n.delay) : 0;
      s &&
        (t.previousNode.type === v.Style ||
          (i == 0 && t.currentTimeline.hasCurrentStyleProperties())) &&
        (t.currentTimeline.snapshotCurrentStyles(), (t.previousNode = Pt));
      let o = i,
        a = t.invokeQuery(
          e.selector,
          e.originalSelector,
          e.limit,
          e.includeSelf,
          !!n.optional,
          t.errors,
        );
      t.currentQueryTotal = a.length;
      let l = null;
      a.forEach((c, m) => {
        t.currentQueryIndex = m;
        let u = t.createSubContext(e.options, c);
        s && u.delayNextStep(s),
          c === t.element && (l = u.currentTimeline),
          K(this, e.animation, u),
          u.currentTimeline.applyStylesToKeyframe();
        let _ = u.currentTimeline.currentTime;
        o = Math.max(o, _);
      }),
        (t.currentQueryIndex = 0),
        (t.currentQueryTotal = 0),
        t.transformIntoNewTimeline(o),
        l &&
          (t.currentTimeline.mergeTimelineCollectedStyles(l),
          t.currentTimeline.snapshotCurrentStyles()),
        (t.previousNode = e);
    }
    visitStagger(e, t) {
      let i = t.parentContext,
        n = t.currentTimeline,
        s = e.timings,
        o = Math.abs(s.duration),
        a = o * (t.currentQueryTotal - 1),
        l = o * t.currentQueryIndex;
      switch (s.duration < 0 ? "reverse" : s.easing) {
        case "reverse":
          l = a - l;
          break;
        case "full":
          l = i.currentStaggerTime;
          break;
      }
      let m = t.currentTimeline;
      l && m.delayNextStep(l);
      let u = m.currentTime;
      K(this, e.animation, t),
        (t.previousNode = e),
        (i.currentStaggerTime =
          n.currentTime - u + (n.startTime - i.currentTimeline.startTime));
    }
  },
  Pt = {},
  gi = class r {
    constructor(e, t, i, n, s, o, a, l) {
      (this._driver = e),
        (this.element = t),
        (this.subInstructions = i),
        (this._enterClassName = n),
        (this._leaveClassName = s),
        (this.errors = o),
        (this.timelines = a),
        (this.parentContext = null),
        (this.currentAnimateTimings = null),
        (this.previousNode = Pt),
        (this.subContextCount = 0),
        (this.options = {}),
        (this.currentQueryIndex = 0),
        (this.currentQueryTotal = 0),
        (this.currentStaggerTime = 0),
        (this.currentTimeline = l || new It(this._driver, t, 0)),
        a.push(this.currentTimeline);
    }
    get params() {
      return this.options.params;
    }
    updateOptions(e, t) {
      if (!e) return;
      let i = e,
        n = this.options;
      i.duration != null && (n.duration = oe(i.duration)),
        i.delay != null && (n.delay = oe(i.delay));
      let s = i.params;
      if (s) {
        let o = n.params;
        o || (o = this.options.params = {}),
          Object.keys(s).forEach((a) => {
            (!t || !o.hasOwnProperty(a)) && (o[a] = He(s[a], o, this.errors));
          });
      }
    }
    _copyOptions() {
      let e = {};
      if (this.options) {
        let t = this.options.params;
        if (t) {
          let i = (e.params = {});
          Object.keys(t).forEach((n) => {
            i[n] = t[n];
          });
        }
      }
      return e;
    }
    createSubContext(e = null, t, i) {
      let n = t || this.element,
        s = new r(
          this._driver,
          n,
          this.subInstructions,
          this._enterClassName,
          this._leaveClassName,
          this.errors,
          this.timelines,
          this.currentTimeline.fork(n, i || 0),
        );
      return (
        (s.previousNode = this.previousNode),
        (s.currentAnimateTimings = this.currentAnimateTimings),
        (s.options = this._copyOptions()),
        s.updateOptions(e),
        (s.currentQueryIndex = this.currentQueryIndex),
        (s.currentQueryTotal = this.currentQueryTotal),
        (s.parentContext = this),
        this.subContextCount++,
        s
      );
    }
    transformIntoNewTimeline(e) {
      return (
        (this.previousNode = Pt),
        (this.currentTimeline = this.currentTimeline.fork(this.element, e)),
        this.timelines.push(this.currentTimeline),
        this.currentTimeline
      );
    }
    appendInstructionToTimeline(e, t, i) {
      let n = {
          duration: t ?? e.duration,
          delay: this.currentTimeline.currentTime + (i ?? 0) + e.delay,
          easing: "",
        },
        s = new yi(
          this._driver,
          e.element,
          e.keyframes,
          e.preStyleProps,
          e.postStyleProps,
          n,
          e.stretchStartingKeyframe,
        );
      return this.timelines.push(s), n;
    }
    incrementTime(e) {
      this.currentTimeline.forwardTime(this.currentTimeline.duration + e);
    }
    delayNextStep(e) {
      e > 0 && this.currentTimeline.delayNextStep(e);
    }
    invokeQuery(e, t, i, n, s, o) {
      let a = [];
      if ((n && a.push(this.element), e.length > 0)) {
        (e = e.replace(so, "." + this._enterClassName)),
          (e = e.replace(oo, "." + this._leaveClassName));
        let l = i != 1,
          c = this._driver.query(this.element, e, l);
        i !== 0 &&
          (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)),
          a.push(...c);
      }
      return !s && a.length == 0 && o.push(br(t)), a;
    }
  },
  It = class r {
    constructor(e, t, i, n) {
      (this._driver = e),
        (this.element = t),
        (this.startTime = i),
        (this._elementTimelineStylesLookup = n),
        (this.duration = 0),
        (this.easing = null),
        (this._previousKeyframe = new Map()),
        (this._currentKeyframe = new Map()),
        (this._keyframes = new Map()),
        (this._styleSummary = new Map()),
        (this._localTimelineStyles = new Map()),
        (this._pendingStyles = new Map()),
        (this._backFill = new Map()),
        (this._currentEmptyStepKeyframe = null),
        this._elementTimelineStylesLookup ||
          (this._elementTimelineStylesLookup = new Map()),
        (this._globalTimelineStyles = this._elementTimelineStylesLookup.get(t)),
        this._globalTimelineStyles ||
          ((this._globalTimelineStyles = this._localTimelineStyles),
          this._elementTimelineStylesLookup.set(t, this._localTimelineStyles)),
        this._loadKeyframe();
    }
    containsAnimation() {
      switch (this._keyframes.size) {
        case 0:
          return !1;
        case 1:
          return this.hasCurrentStyleProperties();
        default:
          return !0;
      }
    }
    hasCurrentStyleProperties() {
      return this._currentKeyframe.size > 0;
    }
    get currentTime() {
      return this.startTime + this.duration;
    }
    delayNextStep(e) {
      let t = this._keyframes.size === 1 && this._pendingStyles.size;
      this.duration || t
        ? (this.forwardTime(this.currentTime + e),
          t && this.snapshotCurrentStyles())
        : (this.startTime += e);
    }
    fork(e, t) {
      return (
        this.applyStylesToKeyframe(),
        new r(
          this._driver,
          e,
          t || this.currentTime,
          this._elementTimelineStylesLookup,
        )
      );
    }
    _loadKeyframe() {
      this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe),
        (this._currentKeyframe = this._keyframes.get(this.duration)),
        this._currentKeyframe ||
          ((this._currentKeyframe = new Map()),
          this._keyframes.set(this.duration, this._currentKeyframe));
    }
    forwardFrame() {
      (this.duration += io), this._loadKeyframe();
    }
    forwardTime(e) {
      this.applyStylesToKeyframe(), (this.duration = e), this._loadKeyframe();
    }
    _updateStyle(e, t) {
      this._localTimelineStyles.set(e, t),
        this._globalTimelineStyles.set(e, t),
        this._styleSummary.set(e, { time: this.currentTime, value: t });
    }
    allowOnlyTimelineStyles() {
      return this._currentEmptyStepKeyframe !== this._currentKeyframe;
    }
    applyEmptyStep(e) {
      e && this._previousKeyframe.set("easing", e);
      for (let [t, i] of this._globalTimelineStyles)
        this._backFill.set(t, i || J), this._currentKeyframe.set(t, J);
      this._currentEmptyStepKeyframe = this._currentKeyframe;
    }
    setStyles(e, t, i, n) {
      t && this._previousKeyframe.set("easing", t);
      let s = (n && n.params) || {},
        o = ao(e, this._globalTimelineStyles);
      for (let [a, l] of o) {
        let c = He(l, s, i);
        this._pendingStyles.set(a, c),
          this._localTimelineStyles.has(a) ||
            this._backFill.set(a, this._globalTimelineStyles.get(a) ?? J),
          this._updateStyle(a, c);
      }
    }
    applyStylesToKeyframe() {
      this._pendingStyles.size != 0 &&
        (this._pendingStyles.forEach((e, t) => {
          this._currentKeyframe.set(t, e);
        }),
        this._pendingStyles.clear(),
        this._localTimelineStyles.forEach((e, t) => {
          this._currentKeyframe.has(t) || this._currentKeyframe.set(t, e);
        }));
    }
    snapshotCurrentStyles() {
      for (let [e, t] of this._localTimelineStyles)
        this._pendingStyles.set(e, t), this._updateStyle(e, t);
    }
    getFinalKeyframe() {
      return this._keyframes.get(this.duration);
    }
    get properties() {
      let e = [];
      for (let t in this._currentKeyframe) e.push(t);
      return e;
    }
    mergeTimelineCollectedStyles(e) {
      e._styleSummary.forEach((t, i) => {
        let n = this._styleSummary.get(i);
        (!n || t.time > n.time) && this._updateStyle(i, t.value);
      });
    }
    buildKeyframes() {
      this.applyStylesToKeyframe();
      let e = new Set(),
        t = new Set(),
        i = this._keyframes.size === 1 && this.duration === 0,
        n = [];
      this._keyframes.forEach((a, l) => {
        let c = new Map([...this._backFill, ...a]);
        c.forEach((m, u) => {
          m === dt ? e.add(u) : m === J && t.add(u);
        }),
          i || c.set("offset", l / this.duration),
          n.push(c);
      });
      let s = [...e.values()],
        o = [...t.values()];
      if (i) {
        let a = n[0],
          l = new Map(a);
        a.set("offset", 0), l.set("offset", 1), (n = [a, l]);
      }
      return ki(
        this.element,
        n,
        s,
        o,
        this.duration,
        this.startTime,
        this.easing,
        !1,
      );
    }
  },
  yi = class extends It {
    constructor(e, t, i, n, s, o, a = !1) {
      super(e, t, o.delay),
        (this.keyframes = i),
        (this.preStyleProps = n),
        (this.postStyleProps = s),
        (this._stretchStartingKeyframe = a),
        (this.timings = {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
        });
    }
    containsAnimation() {
      return this.keyframes.length > 1;
    }
    buildKeyframes() {
      let e = this.keyframes,
        { delay: t, duration: i, easing: n } = this.timings;
      if (this._stretchStartingKeyframe && t) {
        let s = [],
          o = i + t,
          a = t / o,
          l = new Map(e[0]);
        l.set("offset", 0), s.push(l);
        let c = new Map(e[0]);
        c.set("offset", ls(a)), s.push(c);
        let m = e.length - 1;
        for (let u = 1; u <= m; u++) {
          let _ = new Map(e[u]),
            g = _.get("offset"),
            h = t + g * i;
          _.set("offset", ls(h / o)), s.push(_);
        }
        (i = o), (t = 0), (n = ""), (e = s);
      }
      return ki(
        this.element,
        e,
        this.preStyleProps,
        this.postStyleProps,
        i,
        t,
        n,
        !0,
      );
    }
  };
function ls(r, e = 3) {
  let t = Math.pow(10, e - 1);
  return Math.round(r * t) / t;
}
function ao(r, e) {
  let t = new Map(),
    i;
  return (
    r.forEach((n) => {
      if (n === "*") {
        i ??= e.keys();
        for (let s of i) t.set(s, J);
      } else for (let [s, o] of n) t.set(s, o);
    }),
    t
  );
}
function cs(r, e, t, i, n, s, o, a, l, c, m, u, _) {
  return {
    type: 0,
    element: r,
    triggerName: e,
    isRemovalTransition: n,
    fromState: t,
    fromStyles: s,
    toState: i,
    toStyles: o,
    timelines: a,
    queriedElements: l,
    preStyleProps: c,
    postStyleProps: m,
    totalTime: u,
    errors: _,
  };
}
var ri = {},
  Dt = class {
    constructor(e, t, i) {
      (this._triggerName = e), (this.ast = t), (this._stateStyles = i);
    }
    match(e, t, i, n) {
      return lo(this.ast.matchers, e, t, i, n);
    }
    buildStyles(e, t, i) {
      let n = this._stateStyles.get("*");
      return (
        e !== void 0 && (n = this._stateStyles.get(e?.toString()) || n),
        n ? n.buildStyles(t, i) : new Map()
      );
    }
    build(e, t, i, n, s, o, a, l, c, m) {
      let u = [],
        _ = (this.ast.options && this.ast.options.params) || ri,
        g = (a && a.params) || ri,
        h = this.buildStyles(i, g, u),
        y = (l && l.params) || ri,
        T = this.buildStyles(n, y, u),
        P = new Set(),
        I = new Map(),
        F = new Map(),
        k = n === "void",
        we = { params: Ms(y, _), delay: this.ast.options?.delay },
        Y = m ? [] : Ts(e, t, this.ast.animation, s, o, h, T, we, c, u),
        O = 0;
      return (
        Y.forEach((x) => {
          O = Math.max(x.duration + x.delay, O);
        }),
        u.length
          ? cs(t, this._triggerName, i, n, k, h, T, [], [], I, F, O, u)
          : (Y.forEach((x) => {
              let me = x.element,
                Te = V(I, me, new Set());
              x.preStyleProps.forEach((ue) => Te.add(ue));
              let Ri = V(F, me, new Set());
              x.postStyleProps.forEach((ue) => Ri.add(ue)),
                me !== t && P.add(me);
            }),
            cs(
              t,
              this._triggerName,
              i,
              n,
              k,
              h,
              T,
              Y,
              [...P.values()],
              I,
              F,
              O,
            ))
      );
    }
  };
function lo(r, e, t, i, n) {
  return r.some((s) => s(e, t, i, n));
}
function Ms(r, e) {
  let t = Ze({}, e);
  return (
    Object.entries(r).forEach(([i, n]) => {
      n != null && (t[i] = n);
    }),
    t
  );
}
var _i = class {
  constructor(e, t, i) {
    (this.styles = e), (this.defaultParams = t), (this.normalizer = i);
  }
  buildStyles(e, t) {
    let i = new Map(),
      n = Ms(e, this.defaultParams);
    return (
      this.styles.styles.forEach((s) => {
        typeof s != "string" &&
          s.forEach((o, a) => {
            o && (o = He(o, n, t));
            let l = this.normalizer.normalizePropertyName(a, t);
            (o = this.normalizer.normalizeStyleValue(a, l, o, t)), i.set(a, o);
          });
      }),
      i
    );
  }
};
function co(r, e, t) {
  return new vi(r, e, t);
}
var vi = class {
  constructor(e, t, i) {
    (this.name = e),
      (this.ast = t),
      (this._normalizer = i),
      (this.transitionFactories = []),
      (this.states = new Map()),
      t.states.forEach((n) => {
        let s = (n.options && n.options.params) || {};
        this.states.set(n.name, new _i(n.style, s, i));
      }),
      ms(this.states, "true", "1"),
      ms(this.states, "false", "0"),
      t.transitions.forEach((n) => {
        this.transitionFactories.push(new Dt(e, n, this.states));
      }),
      (this.fallbackTransition = mo(e, this.states, this._normalizer));
  }
  get containsQueries() {
    return this.ast.queryCount > 0;
  }
  matchTransition(e, t, i, n) {
    return this.transitionFactories.find((o) => o.match(e, t, i, n)) || null;
  }
  matchStyles(e, t, i) {
    return this.fallbackTransition.buildStyles(e, t, i);
  }
};
function mo(r, e, t) {
  let i = [(o, a) => !0],
    n = { type: v.Sequence, steps: [], options: null },
    s = {
      type: v.Transition,
      animation: n,
      matchers: i,
      options: null,
      queryCount: 0,
      depCount: 0,
    };
  return new Dt(r, s, e);
}
function ms(r, e, t) {
  r.has(e) ? r.has(t) || r.set(t, r.get(e)) : r.has(t) && r.set(e, r.get(t));
}
var uo = new We(),
  bi = class {
    constructor(e, t, i) {
      (this.bodyNode = e),
        (this._driver = t),
        (this._normalizer = i),
        (this._animations = new Map()),
        (this._playersById = new Map()),
        (this.players = []);
    }
    register(e, t) {
      let i = [],
        n = [],
        s = ws(this._driver, t, i, n);
      if (i.length) throw Mr(i);
      n.length && void 0, this._animations.set(e, s);
    }
    _buildPlayer(e, t, i) {
      let n = e.element,
        s = gs(this._normalizer, e.keyframes, t, i);
      return this._driver.animate(n, s, e.duration, e.delay, e.easing, [], !0);
    }
    create(e, t, i = {}) {
      let n = [],
        s = this._animations.get(e),
        o,
        a = new Map();
      if (
        (s
          ? ((o = Ts(
              this._driver,
              t,
              s,
              bs,
              ci,
              new Map(),
              new Map(),
              i,
              uo,
              n,
            )),
            o.forEach((m) => {
              let u = V(a, m.element, new Map());
              m.postStyleProps.forEach((_) => u.set(_, null));
            }))
          : (n.push(Cr()), (o = [])),
        n.length)
      )
        throw Ar(n);
      a.forEach((m, u) => {
        m.forEach((_, g) => {
          m.set(g, this._driver.computeStyle(u, g, J));
        });
      });
      let l = o.map((m) => {
          let u = a.get(m.element);
          return this._buildPlayer(m, new Map(), u);
        }),
        c = ce(l);
      return (
        this._playersById.set(e, c),
        c.onDestroy(() => this.destroy(e)),
        this.players.push(c),
        c
      );
    }
    destroy(e) {
      let t = this._getPlayer(e);
      t.destroy(), this._playersById.delete(e);
      let i = this.players.indexOf(t);
      i >= 0 && this.players.splice(i, 1);
    }
    _getPlayer(e) {
      let t = this._playersById.get(e);
      if (!t) throw Pr(e);
      return t;
    }
    listen(e, t, i, n) {
      let s = Ci(t, "", "", "");
      return Mi(this._getPlayer(e), i, s, n), () => {};
    }
    command(e, t, i, n) {
      if (i == "register") {
        this.register(e, n[0]);
        return;
      }
      if (i == "create") {
        let o = n[0] || {};
        this.create(e, t, o);
        return;
      }
      let s = this._getPlayer(e);
      switch (i) {
        case "play":
          s.play();
          break;
        case "pause":
          s.pause();
          break;
        case "reset":
          s.reset();
          break;
        case "restart":
          s.restart();
          break;
        case "finish":
          s.finish();
          break;
        case "init":
          s.init();
          break;
        case "setPosition":
          s.setPosition(parseFloat(n[0]));
          break;
        case "destroy":
          this.destroy(e);
          break;
      }
    }
  },
  us = "ng-animate-queued",
  ho = ".ng-animate-queued",
  oi = "ng-animate-disabled",
  fo = ".ng-animate-disabled",
  po = "ng-star-inserted",
  go = ".ng-star-inserted",
  yo = [],
  Cs = {
    namespaceId: "",
    setForRemoval: !1,
    setForMove: !1,
    hasAnimation: !1,
    removedBeforeQueried: !1,
  },
  _o = {
    namespaceId: "",
    setForMove: !1,
    setForRemoval: !1,
    hasAnimation: !1,
    removedBeforeQueried: !0,
  },
  G = "__ng_removed",
  Ge = class {
    get params() {
      return this.options.params;
    }
    constructor(e, t = "") {
      this.namespaceId = t;
      let i = e && e.hasOwnProperty("value"),
        n = i ? e.value : e;
      if (((this.value = bo(n)), i)) {
        let s = e,
          { value: o } = s,
          a = zi(s, ["value"]);
        this.options = a;
      } else this.options = {};
      this.options.params || (this.options.params = {});
    }
    absorbOptions(e) {
      let t = e.params;
      if (t) {
        let i = this.options.params;
        Object.keys(t).forEach((n) => {
          i[n] == null && (i[n] = t[n]);
        });
      }
    }
  },
  Ue = "void",
  ai = new Ge(Ue),
  Ei = class {
    constructor(e, t, i) {
      (this.id = e),
        (this.hostElement = t),
        (this._engine = i),
        (this.players = []),
        (this._triggers = new Map()),
        (this._queue = []),
        (this._elementListeners = new Map()),
        (this._hostClassName = "ng-tns-" + e),
        U(t, this._hostClassName);
    }
    listen(e, t, i, n) {
      if (!this._triggers.has(t)) throw Ir(i, t);
      if (i == null || i.length == 0) throw Dr(t);
      if (!Eo(i)) throw kr(i, t);
      let s = V(this._elementListeners, e, []),
        o = { name: t, phase: i, callback: n };
      s.push(o);
      let a = V(this._engine.statesByElement, e, new Map());
      return (
        a.has(t) || (U(e, vt), U(e, vt + "-" + t), a.set(t, ai)),
        () => {
          this._engine.afterFlush(() => {
            let l = s.indexOf(o);
            l >= 0 && s.splice(l, 1), this._triggers.has(t) || a.delete(t);
          });
        }
      );
    }
    register(e, t) {
      return this._triggers.has(e) ? !1 : (this._triggers.set(e, t), !0);
    }
    _getTrigger(e) {
      let t = this._triggers.get(e);
      if (!t) throw Nr(e);
      return t;
    }
    trigger(e, t, i, n = !0) {
      let s = this._getTrigger(t),
        o = new Ye(this.id, t, e),
        a = this._engine.statesByElement.get(e);
      a ||
        (U(e, vt),
        U(e, vt + "-" + t),
        this._engine.statesByElement.set(e, (a = new Map())));
      let l = a.get(t),
        c = new Ge(i, this.id);
      if (
        (!(i && i.hasOwnProperty("value")) && l && c.absorbOptions(l.options),
        a.set(t, c),
        l || (l = ai),
        !(c.value === Ue) && l.value === c.value)
      ) {
        if (!To(l.params, c.params)) {
          let y = [],
            T = s.matchStyles(l.value, l.params, y),
            P = s.matchStyles(c.value, c.params, y);
          y.length
            ? this._engine.reportError(y)
            : this._engine.afterFlush(() => {
                be(e, T), ee(e, P);
              });
        }
        return;
      }
      let _ = V(this._engine.playersByElement, e, []);
      _.forEach((y) => {
        y.namespaceId == this.id &&
          y.triggerName == t &&
          y.queued &&
          y.destroy();
      });
      let g = s.matchTransition(l.value, c.value, e, c.params),
        h = !1;
      if (!g) {
        if (!n) return;
        (g = s.fallbackTransition), (h = !0);
      }
      return (
        this._engine.totalQueuedPlayers++,
        this._queue.push({
          element: e,
          triggerName: t,
          transition: g,
          fromState: l,
          toState: c,
          player: o,
          isFallbackTransition: h,
        }),
        h ||
          (U(e, us),
          o.onStart(() => {
            Ne(e, us);
          })),
        o.onDone(() => {
          let y = this.players.indexOf(o);
          y >= 0 && this.players.splice(y, 1);
          let T = this._engine.playersByElement.get(e);
          if (T) {
            let P = T.indexOf(o);
            P >= 0 && T.splice(P, 1);
          }
        }),
        this.players.push(o),
        _.push(o),
        o
      );
    }
    deregister(e) {
      this._triggers.delete(e),
        this._engine.statesByElement.forEach((t) => t.delete(e)),
        this._elementListeners.forEach((t, i) => {
          this._elementListeners.set(
            i,
            t.filter((n) => n.name != e),
          );
        });
    }
    clearElementCache(e) {
      this._engine.statesByElement.delete(e), this._elementListeners.delete(e);
      let t = this._engine.playersByElement.get(e);
      t &&
        (t.forEach((i) => i.destroy()),
        this._engine.playersByElement.delete(e));
    }
    _signalRemovalForInnerTriggers(e, t) {
      let i = this._engine.driver.query(e, Tt, !0);
      i.forEach((n) => {
        if (n[G]) return;
        let s = this._engine.fetchNamespacesByElement(n);
        s.size
          ? s.forEach((o) => o.triggerLeaveAnimation(n, t, !1, !0))
          : this.clearElementCache(n);
      }),
        this._engine.afterFlushAnimationsDone(() =>
          i.forEach((n) => this.clearElementCache(n)),
        );
    }
    triggerLeaveAnimation(e, t, i, n) {
      let s = this._engine.statesByElement.get(e),
        o = new Map();
      if (s) {
        let a = [];
        if (
          (s.forEach((l, c) => {
            if ((o.set(c, l.value), this._triggers.has(c))) {
              let m = this.trigger(e, c, Ue, n);
              m && a.push(m);
            }
          }),
          a.length)
        )
          return (
            this._engine.markElementAsRemoved(this.id, e, !0, t, o),
            i && ce(a).onDone(() => this._engine.processLeaveNode(e)),
            !0
          );
      }
      return !1;
    }
    prepareLeaveAnimationListeners(e) {
      let t = this._elementListeners.get(e),
        i = this._engine.statesByElement.get(e);
      if (t && i) {
        let n = new Set();
        t.forEach((s) => {
          let o = s.name;
          if (n.has(o)) return;
          n.add(o);
          let l = this._triggers.get(o).fallbackTransition,
            c = i.get(o) || ai,
            m = new Ge(Ue),
            u = new Ye(this.id, o, e);
          this._engine.totalQueuedPlayers++,
            this._queue.push({
              element: e,
              triggerName: o,
              transition: l,
              fromState: c,
              toState: m,
              player: u,
              isFallbackTransition: !0,
            });
        });
      }
    }
    removeNode(e, t) {
      let i = this._engine;
      if (
        (e.childElementCount && this._signalRemovalForInnerTriggers(e, t),
        this.triggerLeaveAnimation(e, t, !0))
      )
        return;
      let n = !1;
      if (i.totalAnimations) {
        let s = i.players.length ? i.playersByQueriedElement.get(e) : [];
        if (s && s.length) n = !0;
        else {
          let o = e;
          for (; (o = o.parentNode); )
            if (i.statesByElement.get(o)) {
              n = !0;
              break;
            }
        }
      }
      if ((this.prepareLeaveAnimationListeners(e), n))
        i.markElementAsRemoved(this.id, e, !1, t);
      else {
        let s = e[G];
        (!s || s === Cs) &&
          (i.afterFlush(() => this.clearElementCache(e)),
          i.destroyInnerAnimations(e),
          i._onRemovalComplete(e, t));
      }
    }
    insertNode(e, t) {
      U(e, this._hostClassName);
    }
    drainQueuedTransitions(e) {
      let t = [];
      return (
        this._queue.forEach((i) => {
          let n = i.player;
          if (n.destroyed) return;
          let s = i.element,
            o = this._elementListeners.get(s);
          o &&
            o.forEach((a) => {
              if (a.name == i.triggerName) {
                let l = Ci(
                  s,
                  i.triggerName,
                  i.fromState.value,
                  i.toState.value,
                );
                (l._data = e), Mi(i.player, a.phase, l, a.callback);
              }
            }),
            n.markedForDestroy
              ? this._engine.afterFlush(() => {
                  n.destroy();
                })
              : t.push(i);
        }),
        (this._queue = []),
        t.sort((i, n) => {
          let s = i.transition.ast.depCount,
            o = n.transition.ast.depCount;
          return s == 0 || o == 0
            ? s - o
            : this._engine.driver.containsElement(i.element, n.element)
              ? 1
              : -1;
        })
      );
    }
    destroy(e) {
      this.players.forEach((t) => t.destroy()),
        this._signalRemovalForInnerTriggers(this.hostElement, e);
    }
  },
  Si = class {
    _onRemovalComplete(e, t) {
      this.onRemovalComplete(e, t);
    }
    constructor(e, t, i, n) {
      (this.bodyNode = e),
        (this.driver = t),
        (this._normalizer = i),
        (this.scheduler = n),
        (this.players = []),
        (this.newHostElements = new Map()),
        (this.playersByElement = new Map()),
        (this.playersByQueriedElement = new Map()),
        (this.statesByElement = new Map()),
        (this.disabledNodes = new Set()),
        (this.totalAnimations = 0),
        (this.totalQueuedPlayers = 0),
        (this._namespaceLookup = {}),
        (this._namespaceList = []),
        (this._flushFns = []),
        (this._whenQuietFns = []),
        (this.namespacesByHostElement = new Map()),
        (this.collectedEnterElements = []),
        (this.collectedLeaveElements = []),
        (this.onRemovalComplete = (s, o) => {});
    }
    get queuedPlayers() {
      let e = [];
      return (
        this._namespaceList.forEach((t) => {
          t.players.forEach((i) => {
            i.queued && e.push(i);
          });
        }),
        e
      );
    }
    createNamespace(e, t) {
      let i = new Ei(e, t, this);
      return (
        this.bodyNode && this.driver.containsElement(this.bodyNode, t)
          ? this._balanceNamespaceList(i, t)
          : (this.newHostElements.set(t, i), this.collectEnterElement(t)),
        (this._namespaceLookup[e] = i)
      );
    }
    _balanceNamespaceList(e, t) {
      let i = this._namespaceList,
        n = this.namespacesByHostElement;
      if (i.length - 1 >= 0) {
        let o = !1,
          a = this.driver.getParentElement(t);
        for (; a; ) {
          let l = n.get(a);
          if (l) {
            let c = i.indexOf(l);
            i.splice(c + 1, 0, e), (o = !0);
            break;
          }
          a = this.driver.getParentElement(a);
        }
        o || i.unshift(e);
      } else i.push(e);
      return n.set(t, e), e;
    }
    register(e, t) {
      let i = this._namespaceLookup[e];
      return i || (i = this.createNamespace(e, t)), i;
    }
    registerTrigger(e, t, i) {
      let n = this._namespaceLookup[e];
      n && n.register(t, i) && this.totalAnimations++;
    }
    destroy(e, t) {
      e &&
        (this.afterFlush(() => {}),
        this.afterFlushAnimationsDone(() => {
          let i = this._fetchNamespace(e);
          this.namespacesByHostElement.delete(i.hostElement);
          let n = this._namespaceList.indexOf(i);
          n >= 0 && this._namespaceList.splice(n, 1),
            i.destroy(t),
            delete this._namespaceLookup[e];
        }));
    }
    _fetchNamespace(e) {
      return this._namespaceLookup[e];
    }
    fetchNamespacesByElement(e) {
      let t = new Set(),
        i = this.statesByElement.get(e);
      if (i) {
        for (let n of i.values())
          if (n.namespaceId) {
            let s = this._fetchNamespace(n.namespaceId);
            s && t.add(s);
          }
      }
      return t;
    }
    trigger(e, t, i, n) {
      if (St(t)) {
        let s = this._fetchNamespace(e);
        if (s) return s.trigger(t, i, n), !0;
      }
      return !1;
    }
    insertNode(e, t, i, n) {
      if (!St(t)) return;
      let s = t[G];
      if (s && s.setForRemoval) {
        (s.setForRemoval = !1), (s.setForMove = !0);
        let o = this.collectedLeaveElements.indexOf(t);
        o >= 0 && this.collectedLeaveElements.splice(o, 1);
      }
      if (e) {
        let o = this._fetchNamespace(e);
        o && o.insertNode(t, i);
      }
      n && this.collectEnterElement(t);
    }
    collectEnterElement(e) {
      this.collectedEnterElements.push(e);
    }
    markElementAsDisabled(e, t) {
      t
        ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), U(e, oi))
        : this.disabledNodes.has(e) &&
          (this.disabledNodes.delete(e), Ne(e, oi));
    }
    removeNode(e, t, i) {
      if (St(t)) {
        this.scheduler?.notify();
        let n = e ? this._fetchNamespace(e) : null;
        n ? n.removeNode(t, i) : this.markElementAsRemoved(e, t, !1, i);
        let s = this.namespacesByHostElement.get(t);
        s && s.id !== e && s.removeNode(t, i);
      } else this._onRemovalComplete(t, i);
    }
    markElementAsRemoved(e, t, i, n, s) {
      this.collectedLeaveElements.push(t),
        (t[G] = {
          namespaceId: e,
          setForRemoval: n,
          hasAnimation: i,
          removedBeforeQueried: !1,
          previousTriggersValues: s,
        });
    }
    listen(e, t, i, n, s) {
      return St(t) ? this._fetchNamespace(e).listen(t, i, n, s) : () => {};
    }
    _buildInstruction(e, t, i, n, s) {
      return e.transition.build(
        this.driver,
        e.element,
        e.fromState.value,
        e.toState.value,
        i,
        n,
        e.fromState.options,
        e.toState.options,
        t,
        s,
      );
    }
    destroyInnerAnimations(e) {
      let t = this.driver.query(e, Tt, !0);
      t.forEach((i) => this.destroyActiveAnimationsForElement(i)),
        this.playersByQueriedElement.size != 0 &&
          ((t = this.driver.query(e, mi, !0)),
          t.forEach((i) => this.finishActiveQueriedAnimationOnElement(i)));
    }
    destroyActiveAnimationsForElement(e) {
      let t = this.playersByElement.get(e);
      t &&
        t.forEach((i) => {
          i.queued ? (i.markedForDestroy = !0) : i.destroy();
        });
    }
    finishActiveQueriedAnimationOnElement(e) {
      let t = this.playersByQueriedElement.get(e);
      t && t.forEach((i) => i.finish());
    }
    whenRenderingDone() {
      return new Promise((e) => {
        if (this.players.length) return ce(this.players).onDone(() => e());
        e();
      });
    }
    processLeaveNode(e) {
      let t = e[G];
      if (t && t.setForRemoval) {
        if (((e[G] = Cs), t.namespaceId)) {
          this.destroyInnerAnimations(e);
          let i = this._fetchNamespace(t.namespaceId);
          i && i.clearElementCache(e);
        }
        this._onRemovalComplete(e, t.setForRemoval);
      }
      e.classList?.contains(oi) && this.markElementAsDisabled(e, !1),
        this.driver.query(e, fo, !0).forEach((i) => {
          this.markElementAsDisabled(i, !1);
        });
    }
    flush(e = -1) {
      let t = [];
      if (
        (this.newHostElements.size &&
          (this.newHostElements.forEach((i, n) =>
            this._balanceNamespaceList(i, n),
          ),
          this.newHostElements.clear()),
        this.totalAnimations && this.collectedEnterElements.length)
      )
        for (let i = 0; i < this.collectedEnterElements.length; i++) {
          let n = this.collectedEnterElements[i];
          U(n, po);
        }
      if (
        this._namespaceList.length &&
        (this.totalQueuedPlayers || this.collectedLeaveElements.length)
      ) {
        let i = [];
        try {
          t = this._flushAnimations(i, e);
        } finally {
          for (let n = 0; n < i.length; n++) i[n]();
        }
      } else
        for (let i = 0; i < this.collectedLeaveElements.length; i++) {
          let n = this.collectedLeaveElements[i];
          this.processLeaveNode(n);
        }
      if (
        ((this.totalQueuedPlayers = 0),
        (this.collectedEnterElements.length = 0),
        (this.collectedLeaveElements.length = 0),
        this._flushFns.forEach((i) => i()),
        (this._flushFns = []),
        this._whenQuietFns.length)
      ) {
        let i = this._whenQuietFns;
        (this._whenQuietFns = []),
          t.length
            ? ce(t).onDone(() => {
                i.forEach((n) => n());
              })
            : i.forEach((n) => n());
      }
    }
    reportError(e) {
      throw Rr(e);
    }
    _flushAnimations(e, t) {
      let i = new We(),
        n = [],
        s = new Map(),
        o = [],
        a = new Map(),
        l = new Map(),
        c = new Map(),
        m = new Set();
      this.disabledNodes.forEach((d) => {
        m.add(d);
        let f = this.driver.query(d, ho, !0);
        for (let p = 0; p < f.length; p++) m.add(f[p]);
      });
      let u = this.bodyNode,
        _ = Array.from(this.statesByElement.keys()),
        g = fs(_, this.collectedEnterElements),
        h = new Map(),
        y = 0;
      g.forEach((d, f) => {
        let p = bs + y++;
        h.set(f, p), d.forEach((b) => U(b, p));
      });
      let T = [],
        P = new Set(),
        I = new Set();
      for (let d = 0; d < this.collectedLeaveElements.length; d++) {
        let f = this.collectedLeaveElements[d],
          p = f[G];
        p &&
          p.setForRemoval &&
          (T.push(f),
          P.add(f),
          p.hasAnimation
            ? this.driver.query(f, go, !0).forEach((b) => P.add(b))
            : I.add(f));
      }
      let F = new Map(),
        k = fs(_, Array.from(P));
      k.forEach((d, f) => {
        let p = ci + y++;
        F.set(f, p), d.forEach((b) => U(b, p));
      }),
        e.push(() => {
          g.forEach((d, f) => {
            let p = h.get(f);
            d.forEach((b) => Ne(b, p));
          }),
            k.forEach((d, f) => {
              let p = F.get(f);
              d.forEach((b) => Ne(b, p));
            }),
            T.forEach((d) => {
              this.processLeaveNode(d);
            });
        });
      let we = [],
        Y = [];
      for (let d = this._namespaceList.length - 1; d >= 0; d--)
        this._namespaceList[d].drainQueuedTransitions(t).forEach((p) => {
          let b = p.player,
            D = p.element;
          if ((we.push(b), this.collectedEnterElements.length)) {
            let R = D[G];
            if (R && R.setForMove) {
              if (
                R.previousTriggersValues &&
                R.previousTriggersValues.has(p.triggerName)
              ) {
                let de = R.previousTriggersValues.get(p.triggerName),
                  q = this.statesByElement.get(p.element);
                if (q && q.has(p.triggerName)) {
                  let Xe = q.get(p.triggerName);
                  (Xe.value = de), q.set(p.triggerName, Xe);
                }
              }
              b.destroy();
              return;
            }
          }
          let X = !u || !this.driver.containsElement(u, D),
            B = F.get(D),
            ae = h.get(D),
            M = this._buildInstruction(p, i, ae, B, X);
          if (M.errors && M.errors.length) {
            Y.push(M);
            return;
          }
          if (X) {
            b.onStart(() => be(D, M.fromStyles)),
              b.onDestroy(() => ee(D, M.toStyles)),
              n.push(b);
            return;
          }
          if (p.isFallbackTransition) {
            b.onStart(() => be(D, M.fromStyles)),
              b.onDestroy(() => ee(D, M.toStyles)),
              n.push(b);
            return;
          }
          let Li = [];
          M.timelines.forEach((R) => {
            (R.stretchStartingKeyframe = !0),
              this.disabledNodes.has(R.element) || Li.push(R);
          }),
            (M.timelines = Li),
            i.append(D, M.timelines);
          let Os = { instruction: M, player: b, element: D };
          o.push(Os),
            M.queriedElements.forEach((R) => V(a, R, []).push(b)),
            M.preStyleProps.forEach((R, de) => {
              if (R.size) {
                let q = l.get(de);
                q || l.set(de, (q = new Set())),
                  R.forEach((Xe, Lt) => q.add(Lt));
              }
            }),
            M.postStyleProps.forEach((R, de) => {
              let q = c.get(de);
              q || c.set(de, (q = new Set())), R.forEach((Xe, Lt) => q.add(Lt));
            });
        });
      if (Y.length) {
        let d = [];
        Y.forEach((f) => {
          d.push(Fr(f.triggerName, f.errors));
        }),
          we.forEach((f) => f.destroy()),
          this.reportError(d);
      }
      let O = new Map(),
        x = new Map();
      o.forEach((d) => {
        let f = d.element;
        i.has(f) &&
          (x.set(f, f),
          this._beforeAnimationBuild(d.player.namespaceId, d.instruction, O));
      }),
        n.forEach((d) => {
          let f = d.element;
          this._getPreviousPlayers(
            f,
            !1,
            d.namespaceId,
            d.triggerName,
            null,
          ).forEach((b) => {
            V(O, f, []).push(b), b.destroy();
          });
        });
      let me = T.filter((d) => ps(d, l, c)),
        Te = new Map();
      hs(Te, this.driver, I, c, J).forEach((d) => {
        ps(d, l, c) && me.push(d);
      });
      let ue = new Map();
      g.forEach((d, f) => {
        hs(ue, this.driver, new Set(d), l, dt);
      }),
        me.forEach((d) => {
          let f = Te.get(d),
            p = ue.get(d);
          Te.set(
            d,
            new Map([...(f?.entries() ?? []), ...(p?.entries() ?? [])]),
          );
        });
      let Ot = [],
        Fi = [],
        Oi = {};
      o.forEach((d) => {
        let { element: f, player: p, instruction: b } = d;
        if (i.has(f)) {
          if (m.has(f)) {
            p.onDestroy(() => ee(f, b.toStyles)),
              (p.disabled = !0),
              p.overrideTotalTime(b.totalTime),
              n.push(p);
            return;
          }
          let D = Oi;
          if (x.size > 1) {
            let B = f,
              ae = [];
            for (; (B = B.parentNode); ) {
              let M = x.get(B);
              if (M) {
                D = M;
                break;
              }
              ae.push(B);
            }
            ae.forEach((M) => x.set(M, D));
          }
          let X = this._buildAnimation(p.namespaceId, b, O, s, ue, Te);
          if ((p.setRealPlayer(X), D === Oi)) Ot.push(p);
          else {
            let B = this.playersByElement.get(D);
            B && B.length && (p.parentPlayer = ce(B)), n.push(p);
          }
        } else
          be(f, b.fromStyles),
            p.onDestroy(() => ee(f, b.toStyles)),
            Fi.push(p),
            m.has(f) && n.push(p);
      }),
        Fi.forEach((d) => {
          let f = s.get(d.element);
          if (f && f.length) {
            let p = ce(f);
            d.setRealPlayer(p);
          }
        }),
        n.forEach((d) => {
          d.parentPlayer ? d.syncPlayerEvents(d.parentPlayer) : d.destroy();
        });
      for (let d = 0; d < T.length; d++) {
        let f = T[d],
          p = f[G];
        if ((Ne(f, ci), p && p.hasAnimation)) continue;
        let b = [];
        if (a.size) {
          let X = a.get(f);
          X && X.length && b.push(...X);
          let B = this.driver.query(f, mi, !0);
          for (let ae = 0; ae < B.length; ae++) {
            let M = a.get(B[ae]);
            M && M.length && b.push(...M);
          }
        }
        let D = b.filter((X) => !X.destroyed);
        D.length ? So(this, f, D) : this.processLeaveNode(f);
      }
      return (
        (T.length = 0),
        Ot.forEach((d) => {
          this.players.push(d),
            d.onDone(() => {
              d.destroy();
              let f = this.players.indexOf(d);
              this.players.splice(f, 1);
            }),
            d.play();
        }),
        Ot
      );
    }
    afterFlush(e) {
      this._flushFns.push(e);
    }
    afterFlushAnimationsDone(e) {
      this._whenQuietFns.push(e);
    }
    _getPreviousPlayers(e, t, i, n, s) {
      let o = [];
      if (t) {
        let a = this.playersByQueriedElement.get(e);
        a && (o = a);
      } else {
        let a = this.playersByElement.get(e);
        if (a) {
          let l = !s || s == Ue;
          a.forEach((c) => {
            c.queued || (!l && c.triggerName != n) || o.push(c);
          });
        }
      }
      return (
        (i || n) &&
          (o = o.filter(
            (a) => !((i && i != a.namespaceId) || (n && n != a.triggerName)),
          )),
        o
      );
    }
    _beforeAnimationBuild(e, t, i) {
      let n = t.triggerName,
        s = t.element,
        o = t.isRemovalTransition ? void 0 : e,
        a = t.isRemovalTransition ? void 0 : n;
      for (let l of t.timelines) {
        let c = l.element,
          m = c !== s,
          u = V(i, c, []);
        this._getPreviousPlayers(c, m, o, a, t.toState).forEach((g) => {
          let h = g.getRealPlayer();
          h.beforeDestroy && h.beforeDestroy(), g.destroy(), u.push(g);
        });
      }
      be(s, t.fromStyles);
    }
    _buildAnimation(e, t, i, n, s, o) {
      let a = t.triggerName,
        l = t.element,
        c = [],
        m = new Set(),
        u = new Set(),
        _ = t.timelines.map((h) => {
          let y = h.element;
          m.add(y);
          let T = y[G];
          if (T && T.removedBeforeQueried) return new De(h.duration, h.delay);
          let P = y !== l,
            I = wo((i.get(y) || yo).map((O) => O.getRealPlayer())).filter(
              (O) => {
                let x = O;
                return x.element ? x.element === y : !1;
              },
            ),
            F = s.get(y),
            k = o.get(y),
            we = gs(this._normalizer, h.keyframes, F, k),
            Y = this._buildPlayer(h, we, I);
          if ((h.subTimeline && n && u.add(y), P)) {
            let O = new Ye(e, a, y);
            O.setRealPlayer(Y), c.push(O);
          }
          return Y;
        });
      c.forEach((h) => {
        V(this.playersByQueriedElement, h.element, []).push(h),
          h.onDone(() => vo(this.playersByQueriedElement, h.element, h));
      }),
        m.forEach((h) => U(h, rs));
      let g = ce(_);
      return (
        g.onDestroy(() => {
          m.forEach((h) => Ne(h, rs)), ee(l, t.toStyles);
        }),
        u.forEach((h) => {
          V(n, h, []).push(g);
        }),
        g
      );
    }
    _buildPlayer(e, t, i) {
      return t.length > 0
        ? this.driver.animate(e.element, t, e.duration, e.delay, e.easing, i)
        : new De(e.duration, e.delay);
    }
  },
  Ye = class {
    constructor(e, t, i) {
      (this.namespaceId = e),
        (this.triggerName = t),
        (this.element = i),
        (this._player = new De()),
        (this._containsRealPlayer = !1),
        (this._queuedCallbacks = new Map()),
        (this.destroyed = !1),
        (this.parentPlayer = null),
        (this.markedForDestroy = !1),
        (this.disabled = !1),
        (this.queued = !0),
        (this.totalTime = 0);
    }
    setRealPlayer(e) {
      this._containsRealPlayer ||
        ((this._player = e),
        this._queuedCallbacks.forEach((t, i) => {
          t.forEach((n) => Mi(e, i, void 0, n));
        }),
        this._queuedCallbacks.clear(),
        (this._containsRealPlayer = !0),
        this.overrideTotalTime(e.totalTime),
        (this.queued = !1));
    }
    getRealPlayer() {
      return this._player;
    }
    overrideTotalTime(e) {
      this.totalTime = e;
    }
    syncPlayerEvents(e) {
      let t = this._player;
      t.triggerCallback && e.onStart(() => t.triggerCallback("start")),
        e.onDone(() => this.finish()),
        e.onDestroy(() => this.destroy());
    }
    _queueEvent(e, t) {
      V(this._queuedCallbacks, e, []).push(t);
    }
    onDone(e) {
      this.queued && this._queueEvent("done", e), this._player.onDone(e);
    }
    onStart(e) {
      this.queued && this._queueEvent("start", e), this._player.onStart(e);
    }
    onDestroy(e) {
      this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e);
    }
    init() {
      this._player.init();
    }
    hasStarted() {
      return this.queued ? !1 : this._player.hasStarted();
    }
    play() {
      !this.queued && this._player.play();
    }
    pause() {
      !this.queued && this._player.pause();
    }
    restart() {
      !this.queued && this._player.restart();
    }
    finish() {
      this._player.finish();
    }
    destroy() {
      (this.destroyed = !0), this._player.destroy();
    }
    reset() {
      !this.queued && this._player.reset();
    }
    setPosition(e) {
      this.queued || this._player.setPosition(e);
    }
    getPosition() {
      return this.queued ? 0 : this._player.getPosition();
    }
    triggerCallback(e) {
      let t = this._player;
      t.triggerCallback && t.triggerCallback(e);
    }
  };
function vo(r, e, t) {
  let i = r.get(e);
  if (i) {
    if (i.length) {
      let n = i.indexOf(t);
      i.splice(n, 1);
    }
    i.length == 0 && r.delete(e);
  }
  return i;
}
function bo(r) {
  return r ?? null;
}
function St(r) {
  return r && r.nodeType === 1;
}
function Eo(r) {
  return r == "start" || r == "done";
}
function ds(r, e) {
  let t = r.style.display;
  return (r.style.display = e ?? "none"), t;
}
function hs(r, e, t, i, n) {
  let s = [];
  t.forEach((l) => s.push(ds(l)));
  let o = [];
  i.forEach((l, c) => {
    let m = new Map();
    l.forEach((u) => {
      let _ = e.computeStyle(c, u, n);
      m.set(u, _), (!_ || _.length == 0) && ((c[G] = _o), o.push(c));
    }),
      r.set(c, m);
  });
  let a = 0;
  return t.forEach((l) => ds(l, s[a++])), o;
}
function fs(r, e) {
  let t = new Map();
  if ((r.forEach((a) => t.set(a, [])), e.length == 0)) return t;
  let i = 1,
    n = new Set(e),
    s = new Map();
  function o(a) {
    if (!a) return i;
    let l = s.get(a);
    if (l) return l;
    let c = a.parentNode;
    return t.has(c) ? (l = c) : n.has(c) ? (l = i) : (l = o(c)), s.set(a, l), l;
  }
  return (
    e.forEach((a) => {
      let l = o(a);
      l !== i && t.get(l).push(a);
    }),
    t
  );
}
function U(r, e) {
  r.classList?.add(e);
}
function Ne(r, e) {
  r.classList?.remove(e);
}
function So(r, e, t) {
  ce(t).onDone(() => r.processLeaveNode(e));
}
function wo(r) {
  let e = [];
  return As(r, e), e;
}
function As(r, e) {
  for (let t = 0; t < r.length; t++) {
    let i = r[t];
    i instanceof Jt ? As(i.players, e) : e.push(i);
  }
}
function To(r, e) {
  let t = Object.keys(r),
    i = Object.keys(e);
  if (t.length != i.length) return !1;
  for (let n = 0; n < t.length; n++) {
    let s = t[n];
    if (!e.hasOwnProperty(s) || r[s] !== e[s]) return !1;
  }
  return !0;
}
function ps(r, e, t) {
  let i = t.get(r);
  if (!i) return !1;
  let n = e.get(r);
  return n ? i.forEach((s) => n.add(s)) : e.set(r, i), t.delete(r), !0;
}
var Fe = class {
  constructor(e, t, i, n) {
    (this._driver = t),
      (this._normalizer = i),
      (this._triggerCache = {}),
      (this.onRemovalComplete = (s, o) => {}),
      (this._transitionEngine = new Si(e.body, t, i, n)),
      (this._timelineEngine = new bi(e.body, t, i)),
      (this._transitionEngine.onRemovalComplete = (s, o) =>
        this.onRemovalComplete(s, o));
  }
  registerTrigger(e, t, i, n, s) {
    let o = e + "-" + n,
      a = this._triggerCache[o];
    if (!a) {
      let l = [],
        c = [],
        m = ws(this._driver, s, l, c);
      if (l.length) throw wr(n, l);
      c.length && void 0,
        (a = co(n, m, this._normalizer)),
        (this._triggerCache[o] = a);
    }
    this._transitionEngine.registerTrigger(t, n, a);
  }
  register(e, t) {
    this._transitionEngine.register(e, t);
  }
  destroy(e, t) {
    this._transitionEngine.destroy(e, t);
  }
  onInsert(e, t, i, n) {
    this._transitionEngine.insertNode(e, t, i, n);
  }
  onRemove(e, t, i) {
    this._transitionEngine.removeNode(e, t, i);
  }
  disableAnimations(e, t) {
    this._transitionEngine.markElementAsDisabled(e, t);
  }
  process(e, t, i, n) {
    if (i.charAt(0) == "@") {
      let [s, o] = ns(i),
        a = n;
      this._timelineEngine.command(s, t, o, a);
    } else this._transitionEngine.trigger(e, t, i, n);
  }
  listen(e, t, i, n, s) {
    if (i.charAt(0) == "@") {
      let [o, a] = ns(i);
      return this._timelineEngine.listen(o, t, a, s);
    }
    return this._transitionEngine.listen(e, t, i, n, s);
  }
  flush(e = -1) {
    this._transitionEngine.flush(e);
  }
  get players() {
    return [...this._transitionEngine.players, ...this._timelineEngine.players];
  }
  whenRenderingDone() {
    return this._transitionEngine.whenRenderingDone();
  }
  afterFlushAnimationsDone(e) {
    this._transitionEngine.afterFlushAnimationsDone(e);
  }
};
function Mo(r, e) {
  let t = null,
    i = null;
  return (
    Array.isArray(e) && e.length
      ? ((t = li(e[0])), e.length > 1 && (i = li(e[e.length - 1])))
      : e instanceof Map && (t = li(e)),
    t || i ? new wi(r, t, i) : null
  );
}
var Re = class Re {
  constructor(e, t, i) {
    (this._element = e),
      (this._startStyles = t),
      (this._endStyles = i),
      (this._state = 0);
    let n = Re.initialStylesByElement.get(e);
    n || Re.initialStylesByElement.set(e, (n = new Map())),
      (this._initialStyles = n);
  }
  start() {
    this._state < 1 &&
      (this._startStyles &&
        ee(this._element, this._startStyles, this._initialStyles),
      (this._state = 1));
  }
  finish() {
    this.start(),
      this._state < 2 &&
        (ee(this._element, this._initialStyles),
        this._endStyles &&
          (ee(this._element, this._endStyles), (this._endStyles = null)),
        (this._state = 1));
  }
  destroy() {
    this.finish(),
      this._state < 3 &&
        (Re.initialStylesByElement.delete(this._element),
        this._startStyles &&
          (be(this._element, this._startStyles), (this._endStyles = null)),
        this._endStyles &&
          (be(this._element, this._endStyles), (this._endStyles = null)),
        ee(this._element, this._initialStyles),
        (this._state = 3));
  }
};
Re.initialStylesByElement = new WeakMap();
var wi = Re;
function li(r) {
  let e = null;
  return (
    r.forEach((t, i) => {
      Co(i) && ((e = e || new Map()), e.set(i, t));
    }),
    e
  );
}
function Co(r) {
  return r === "display" || r === "position";
}
var kt = class {
    constructor(e, t, i, n) {
      (this.element = e),
        (this.keyframes = t),
        (this.options = i),
        (this._specialStyles = n),
        (this._onDoneFns = []),
        (this._onStartFns = []),
        (this._onDestroyFns = []),
        (this._initialized = !1),
        (this._finished = !1),
        (this._started = !1),
        (this._destroyed = !1),
        (this._originalOnDoneFns = []),
        (this._originalOnStartFns = []),
        (this.time = 0),
        (this.parentPlayer = null),
        (this.currentSnapshot = new Map()),
        (this._duration = i.duration),
        (this._delay = i.delay || 0),
        (this.time = this._duration + this._delay);
    }
    _onFinish() {
      this._finished ||
        ((this._finished = !0),
        this._onDoneFns.forEach((e) => e()),
        (this._onDoneFns = []));
    }
    init() {
      this._buildPlayer(), this._preparePlayerBeforeStart();
    }
    _buildPlayer() {
      if (this._initialized) return;
      this._initialized = !0;
      let e = this.keyframes;
      (this.domPlayer = this._triggerWebAnimation(
        this.element,
        e,
        this.options,
      )),
        (this._finalKeyframe = e.length ? e[e.length - 1] : new Map());
      let t = () => this._onFinish();
      this.domPlayer.addEventListener("finish", t),
        this.onDestroy(() => {
          this.domPlayer.removeEventListener("finish", t);
        });
    }
    _preparePlayerBeforeStart() {
      this._delay ? this._resetDomPlayerState() : this.domPlayer.pause();
    }
    _convertKeyframesToObject(e) {
      let t = [];
      return (
        e.forEach((i) => {
          t.push(Object.fromEntries(i));
        }),
        t
      );
    }
    _triggerWebAnimation(e, t, i) {
      return e.animate(this._convertKeyframesToObject(t), i);
    }
    onStart(e) {
      this._originalOnStartFns.push(e), this._onStartFns.push(e);
    }
    onDone(e) {
      this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
    }
    onDestroy(e) {
      this._onDestroyFns.push(e);
    }
    play() {
      this._buildPlayer(),
        this.hasStarted() ||
          (this._onStartFns.forEach((e) => e()),
          (this._onStartFns = []),
          (this._started = !0),
          this._specialStyles && this._specialStyles.start()),
        this.domPlayer.play();
    }
    pause() {
      this.init(), this.domPlayer.pause();
    }
    finish() {
      this.init(),
        this._specialStyles && this._specialStyles.finish(),
        this._onFinish(),
        this.domPlayer.finish();
    }
    reset() {
      this._resetDomPlayerState(),
        (this._destroyed = !1),
        (this._finished = !1),
        (this._started = !1),
        (this._onStartFns = this._originalOnStartFns),
        (this._onDoneFns = this._originalOnDoneFns);
    }
    _resetDomPlayerState() {
      this.domPlayer && this.domPlayer.cancel();
    }
    restart() {
      this.reset(), this.play();
    }
    hasStarted() {
      return this._started;
    }
    destroy() {
      this._destroyed ||
        ((this._destroyed = !0),
        this._resetDomPlayerState(),
        this._onFinish(),
        this._specialStyles && this._specialStyles.destroy(),
        this._onDestroyFns.forEach((e) => e()),
        (this._onDestroyFns = []));
    }
    setPosition(e) {
      this.domPlayer === void 0 && this.init(),
        (this.domPlayer.currentTime = e * this.time);
    }
    getPosition() {
      return +(this.domPlayer.currentTime ?? 0) / this.time;
    }
    get totalTime() {
      return this._delay + this._duration;
    }
    beforeDestroy() {
      let e = new Map();
      this.hasStarted() &&
        this._finalKeyframe.forEach((i, n) => {
          n !== "offset" && e.set(n, this._finished ? i : Di(this.element, n));
        }),
        (this.currentSnapshot = e);
    }
    triggerCallback(e) {
      let t = e === "start" ? this._onStartFns : this._onDoneFns;
      t.forEach((i) => i()), (t.length = 0);
    }
  },
  Nt = class {
    validateStyleProperty(e) {
      return !0;
    }
    validateAnimatableStyleProperty(e) {
      return !0;
    }
    matchesElement(e, t) {
      return !1;
    }
    containsElement(e, t) {
      return ys(e, t);
    }
    getParentElement(e) {
      return Ai(e);
    }
    query(e, t, i) {
      return _s(e, t, i);
    }
    computeStyle(e, t, i) {
      return Di(e, t);
    }
    animate(e, t, i, n, s, o = []) {
      let a = n == 0 ? "both" : "forwards",
        l = { duration: i, delay: n, fill: a };
      s && (l.easing = s);
      let c = new Map(),
        m = o.filter((g) => g instanceof kt);
      $r(i, n) &&
        m.forEach((g) => {
          g.currentSnapshot.forEach((h, y) => c.set(y, h));
        });
      let u = Vr(t).map((g) => new Map(g));
      u = Ur(e, u, c);
      let _ = Mo(e, u);
      return new kt(e, u, l, _);
    }
  };
var wt = "@",
  Ps = "@.disabled",
  Rt = class {
    constructor(e, t, i, n) {
      (this.namespaceId = e),
        (this.delegate = t),
        (this.engine = i),
        (this._onDestroy = n),
        (this.ɵtype = 0);
    }
    get data() {
      return this.delegate.data;
    }
    destroyNode(e) {
      this.delegate.destroyNode?.(e);
    }
    destroy() {
      this.engine.destroy(this.namespaceId, this.delegate),
        this.engine.afterFlushAnimationsDone(() => {
          queueMicrotask(() => {
            this.delegate.destroy();
          });
        }),
        this._onDestroy?.();
    }
    createElement(e, t) {
      return this.delegate.createElement(e, t);
    }
    createComment(e) {
      return this.delegate.createComment(e);
    }
    createText(e) {
      return this.delegate.createText(e);
    }
    appendChild(e, t) {
      this.delegate.appendChild(e, t),
        this.engine.onInsert(this.namespaceId, t, e, !1);
    }
    insertBefore(e, t, i, n = !0) {
      this.delegate.insertBefore(e, t, i),
        this.engine.onInsert(this.namespaceId, t, e, n);
    }
    removeChild(e, t, i) {
      this.engine.onRemove(this.namespaceId, t, this.delegate);
    }
    selectRootElement(e, t) {
      return this.delegate.selectRootElement(e, t);
    }
    parentNode(e) {
      return this.delegate.parentNode(e);
    }
    nextSibling(e) {
      return this.delegate.nextSibling(e);
    }
    setAttribute(e, t, i, n) {
      this.delegate.setAttribute(e, t, i, n);
    }
    removeAttribute(e, t, i) {
      this.delegate.removeAttribute(e, t, i);
    }
    addClass(e, t) {
      this.delegate.addClass(e, t);
    }
    removeClass(e, t) {
      this.delegate.removeClass(e, t);
    }
    setStyle(e, t, i, n) {
      this.delegate.setStyle(e, t, i, n);
    }
    removeStyle(e, t, i) {
      this.delegate.removeStyle(e, t, i);
    }
    setProperty(e, t, i) {
      t.charAt(0) == wt && t == Ps
        ? this.disableAnimations(e, !!i)
        : this.delegate.setProperty(e, t, i);
    }
    setValue(e, t) {
      this.delegate.setValue(e, t);
    }
    listen(e, t, i) {
      return this.delegate.listen(e, t, i);
    }
    disableAnimations(e, t) {
      this.engine.disableAnimations(e, t);
    }
  },
  Ti = class extends Rt {
    constructor(e, t, i, n, s) {
      super(t, i, n, s), (this.factory = e), (this.namespaceId = t);
    }
    setProperty(e, t, i) {
      t.charAt(0) == wt
        ? t.charAt(1) == "." && t == Ps
          ? ((i = i === void 0 ? !0 : !!i), this.disableAnimations(e, i))
          : this.engine.process(this.namespaceId, e, t.slice(1), i)
        : this.delegate.setProperty(e, t, i);
    }
    listen(e, t, i) {
      if (t.charAt(0) == wt) {
        let n = Ao(e),
          s = t.slice(1),
          o = "";
        return (
          s.charAt(0) != wt && ([s, o] = Po(s)),
          this.engine.listen(this.namespaceId, n, s, o, (a) => {
            let l = a._data || -1;
            this.factory.scheduleListenerCallback(l, i, a);
          })
        );
      }
      return this.delegate.listen(e, t, i);
    }
  };
function Ao(r) {
  switch (r) {
    case "body":
      return document.body;
    case "document":
      return document;
    case "window":
      return window;
    default:
      return r;
  }
}
function Po(r) {
  let e = r.indexOf("."),
    t = r.substring(0, e),
    i = r.slice(e + 1);
  return [t, i];
}
var Ft = class {
  constructor(e, t, i) {
    (this.delegate = e),
      (this.engine = t),
      (this._zone = i),
      (this._currentId = 0),
      (this._microtaskId = 1),
      (this._animationCallbacksBuffer = []),
      (this._rendererCache = new Map()),
      (this._cdRecurDepth = 0),
      (t.onRemovalComplete = (n, s) => {
        let o = s?.parentNode(n);
        o && s.removeChild(o, n);
      });
  }
  createRenderer(e, t) {
    let i = "",
      n = this.delegate.createRenderer(e, t);
    if (!e || !t?.data?.animation) {
      let c = this._rendererCache,
        m = c.get(n);
      if (!m) {
        let u = () => c.delete(n);
        (m = new Rt(i, n, this.engine, u)), c.set(n, m);
      }
      return m;
    }
    let s = t.id,
      o = t.id + "-" + this._currentId;
    this._currentId++, this.engine.register(o, e);
    let a = (c) => {
      Array.isArray(c)
        ? c.forEach(a)
        : this.engine.registerTrigger(s, o, e, c.name, c);
    };
    return t.data.animation.forEach(a), new Ti(this, o, n, this.engine);
  }
  begin() {
    this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
  }
  _scheduleCountTask() {
    queueMicrotask(() => {
      this._microtaskId++;
    });
  }
  scheduleListenerCallback(e, t, i) {
    if (e >= 0 && e < this._microtaskId) {
      this._zone.run(() => t(i));
      return;
    }
    let n = this._animationCallbacksBuffer;
    n.length == 0 &&
      queueMicrotask(() => {
        this._zone.run(() => {
          n.forEach((s) => {
            let [o, a] = s;
            o(a);
          }),
            (this._animationCallbacksBuffer = []);
        });
      }),
      n.push([t, i]);
  }
  end() {
    this._cdRecurDepth--,
      this._cdRecurDepth == 0 &&
        this._zone.runOutsideAngular(() => {
          this._scheduleCountTask(), this.engine.flush(this._microtaskId);
        }),
      this.delegate.end && this.delegate.end();
  }
  whenRenderingDone() {
    return this.engine.whenRenderingDone();
  }
};
var Do = (() => {
  let e = class e extends Fe {
    constructor(i, n, s) {
      super(i, n, s, N(qi, { optional: !0 }));
    }
    ngOnDestroy() {
      this.flush();
    }
  };
  (e.ɵfac = function (n) {
    return new (n || e)(Ce(le), Ce(Ee), Ce(Se));
  }),
    (e.ɵprov = Me({ token: e, factory: e.ɵfac }));
  let r = e;
  return r;
})();
function ko() {
  return new Ct();
}
function No(r, e, t) {
  return new Ft(r, e, t);
}
var Is = [
    { provide: Se, useFactory: ko },
    { provide: Fe, useClass: Do },
    { provide: Qi, useFactory: No, deps: [yn, Fe, he] },
  ],
  Ro = [
    { provide: Ee, useFactory: () => new Nt() },
    { provide: ze, useValue: "BrowserAnimations" },
    ...Is,
  ],
  ul = [
    { provide: Ee, useClass: Pi },
    { provide: ze, useValue: "NoopAnimations" },
    ...Is,
  ];
function Ds() {
  return Ui("NgEagerAnimations"), [...Ro];
}
var ks = (() => {
  let e = class e {
    constructor(i) {
      this.notificationService = i;
    }
    intercept(i, n) {
      return n.handle(i).pipe(
        xi({
          error: () => {
            let s = new URL(i.url);
            this.notificationService.showError(
              `Request to "${s.pathname}" failed. Check the console for the details`,
              0,
            );
          },
        }),
      );
    }
  };
  (e.ɵfac = function (n) {
    return new (n || e)(Ce(zn));
  }),
    (e.ɵprov = Me({ token: e, factory: e.ɵfac }));
  let r = e;
  return r;
})();
var Fo = ["cartBtn"],
  Oo = ["controls"];
function Lo(r, e) {
  if (r & 1) {
    let t = Ke();
    C(0, "button", 6, 0),
      fe("click", function () {
        te(t);
        let n = $();
        return ie(n.add());
      }),
      C(2, "mat-icon"),
      Z(3, "shopping_cart"),
      A()();
  }
  if (r & 2) {
    let t = $();
    Zi("matTooltip", "Add ", t.product().title, " to cart");
  }
}
function zo(r, e) {
  if (r & 1) {
    let t = Ke();
    C(0, "app-cart-count-controls", 7, 1),
      fe("increment", function () {
        te(t);
        let n = $();
        return ie(n.add());
      })("decrement", function () {
        te(t);
        let n = $();
        return ie(n.remove());
      }),
      A();
  }
  if (r & 2) {
    let t = $();
    W("productName", t.product().title)("count", t.countInCart())(
      "available",
      t.product().count,
    );
  }
}
var Ns = (() => {
  var e, t;
  let i = class i {
    constructor() {
      zt(this, e, void 0);
      zt(this, t, void 0);
      (this.product = Qt.required()),
        (this.index = Qt.required()),
        (this.cartBtn = Ut("cartBtn", { read: H })),
        (this.countControls = Ut("controls", { read: gt })),
        xt(this, e, N(qt)),
        xt(this, t, N(lt)),
        (this.countInCart = ln(() => {
          let s = Je(this, t).cart();
          return this.id in s ? s[this.id] : 0;
        })),
        this.updateFocusIfNeeded();
    }
    get id() {
      return this.product().id;
    }
    add() {
      Je(this, t).addItem(this.id);
    }
    remove() {
      Je(this, t).removeItem(this.id);
    }
    updateFocusIfNeeded() {
      let s;
      cn(() => {
        let o = this.countInCart();
        s === 0 && o === 1
          ? setTimeout(() => this.countControls()?.focusAddBtn())
          : s === 1 &&
            o === 0 &&
            setTimeout(() => this.cartBtn()?.nativeElement.focus()),
          (s = o);
      });
    }
  };
  (e = new WeakMap()),
    (t = new WeakMap()),
    (i.ɵfac = function (o) {
      return new (o || i)();
    }),
    (i.ɵcmp = L({
      type: i,
      selectors: [["app-product-item"]],
      viewQuery: function (o, a) {
        o & 1 && (Ht(a.cartBtn, Fo, 5, H), Ht(a.countControls, Oo, 5, gt)),
          o & 2 && en(2);
      },
      inputs: {
        product: [w.SignalBased, "product"],
        index: [w.SignalBased, "index"],
      },
      standalone: !0,
      features: [z],
      decls: 15,
      vars: 9,
      consts: [
        ["cartBtn", ""],
        ["controls", "countControls"],
        ["mat-card-image", "", 1, "img-container"],
        [1, "img-container__inner"],
        ["alt", "", 3, "src"],
        ["color", "accent", "mat-icon-button", ""],
        ["color", "accent", "mat-icon-button", "", 3, "click", "matTooltip"],
        [3, "increment", "decrement", "productName", "count", "available"],
      ],
      template: function (o, a) {
        o & 1 &&
          (C(0, "mat-card")(1, "div", 2)(2, "div", 3),
          Q(3, "img", 4),
          A()(),
          C(4, "mat-card-header")(5, "mat-card-title"),
          Z(6),
          A()(),
          C(7, "mat-card-content")(8, "p"),
          Z(9),
          Wt(10, "number"),
          Wt(11, "currency"),
          A()(),
          C(12, "mat-card-actions"),
          Be(13, Lo, 4, 2, "button", 5)(14, zo, 2, 3),
          A()()),
          o & 2 &&
            (j(3),
            W("src", a.product().image, Vi),
            j(3),
            sn(" ", a.product().title, " "),
            j(3),
            nn(on(11, 7, an(10, 4, a.product().price, "1.2-2"))),
            j(4),
            at(13, a.countInCart() === 0 ? 13 : 14));
      },
      dependencies: [Bn, Qn, qn, jn, Kn, Vn, ft, pt, ct, gt, dn, hn],
      styles: [
        ".img-container[_ngcontent-%COMP%]{padding-top:90%;position:relative}.img-container__inner[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%}.img-container[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{object-fit:cover;width:100%;height:100%;object-position:center center}",
      ],
      changeDetection: 0,
    }));
  let r = i;
  return r;
})();
function xo(r, e) {
  if ((r & 1 && Q(0, "app-product-item", 1), r & 2)) {
    let t = e.$implicit,
      i = e.$index;
    W("product", t)("index", i);
  }
}
var Rs = (() => {
  let e = class e {
    constructor() {
      this.products = $n(N(xn).getProducts(), { initialValue: [] });
    }
  };
  (e.ɵfac = function (n) {
    return new (n || e)();
  }),
    (e.ɵcmp = L({
      type: e,
      selectors: [["app-products"]],
      standalone: !0,
      features: [z],
      decls: 3,
      vars: 0,
      consts: [
        [1, "container"],
        [3, "product", "index"],
      ],
      template: function (n, s) {
        n & 1 &&
          (C(0, "main", 0), Yi(1, xo, 1, 2, "app-product-item", null, Gi), A()),
          n & 2 && (j(), Xi(s.products()));
      },
      dependencies: [Ns],
      styles: [
        ".container[_ngcontent-%COMP%]{display:grid;grid-template-columns:1fr;grid-gap:30px}@media (min-width: 768px){.container[_ngcontent-%COMP%]{grid-template-columns:1fr 1fr}}@media (min-width: 992px){.container[_ngcontent-%COMP%]{grid-template-columns:1fr 1fr 1fr}}",
      ],
      changeDetection: 0,
    }));
  let r = e;
  return r;
})();
var Fs = [
  { path: "", component: Rs },
  { path: "cart", loadChildren: () => import("./chunk-X4DNESFU.js") },
  { path: "admin", loadChildren: () => import("./chunk-GEWBANTE.js") },
];
var Bo = [{ provide: fn, useClass: ks, multi: !0 }];
_n(ts, {
  providers: [En(Fs, Sn()), Bo, { provide: Ln, useValue: Un }, Ds(), pn(gn())],
}).catch((r) => console.error(r));
